{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JoSIM - Superconducting Circuit Simulator Developers Manual for v2.5.1 Project Status Testing: v2.6 - Status: Stable: v2.6 - Status: Introduction JoSIM was developed under IARPA contract SuperTools(via the U.S. Army Research Office grant W911NF-17-1-0120). JoSIM is a analogue circuit simulator with SPICE syntax input that has inherent support for the superconducting Josephson junction element. JoSIM is meant to function as an alternative to the simulators such as JSIM 1 and WRspice 2 . JoSIM is written in modern C++ and is fully customizable and extendable to offer support for improved superconducting elements as well better approximations to the Josephson effect in superconducting materials. A .cir file containing a SPICE syntax circuit netlist is provided as input. The circuit netlist, given appropriate input excitations can then be simulated through transient analysis. Results of this simulation can be dumped to standard output or saved in various formats such as a comma separated value ( .csv ) file. Below is a macro overview of the process performed by JoSIM. This is very basic and is discussed in further detail in the Technical Discussion section of the documentation. Project layout The JoSIM repository has the following layout. A quick description shows the purpose of the various files and folders. cmake # CMake scripts. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. include/ JoSIM # JoSIM header files. scripts # Some Python3 scripts to automate testing and plotting site # Where this documentation spawns from. src/ ... # JoSIM source files. test # Folder containing various examples. README.md # Basic readme to get the user going. LICENSE # License that governs use of JoSIM. CMakeLists.txt # Configuration to compile code. ... # Other configuration files and scripts. Initial setup With each major version of JoSIM a release for all major platforms is generated and placed under the Releases section of the GitHub repository. At the time of writing, this is version 2.5. To compile JoSIM from source, the following packages are required: CMake 3.14 Git C++ compiler with C++17 support Building from source Linux These instructions were executed on a minimal install of CentOS 7 to reduce oversight in the compilation instructions created by previous package installs. For other distributions please use the package manager relevant to the distribution of choice. A working internet connection is required, as well as the ability to install packages. If the internet connection is not up please run, and replace with your relevant interface i.e eth0 : sudo ifup <network interface> CentOS 7 does not contain all the enterprise Linux packages in its default repository and therefore needs to be activated using: sudo yum install epel-release sudo yum update CentOS 7 will require development packages to be installed. Fortunately this can be done using a single command: sudo yum groupinstall \"Development Tools\" This will install various development tools such as gcc , make and git . JoSIM, however, requires a newer version of gcc than the one supplied within these packages. Fortunately this can be installed fairly easily by running the following: sudo yum install centos-release-scl sudo yum install devtoolset-8 scl enable devtoolset-8 bash The last command needs to be entered whenever the newer gcc is needed. This can fortunately be shortened using an alias: echo 'alias dts8=\"scl enable devtoolset-8 bash\"' >> ~/.bashrc This will enable the devtoolset-8 environment on the current bash by just entering the command dts8 . To simplify installation of various packages we make use of Python 3 and pip: sudo install python36 python36-pip This allows installation of the most relevant package version of cmake : pip3 install cmake --user We are now ready to compile JoSIM JoSIM source can be directly downloaded from the repository as a compressed .tar.gz file or by cloning the repository. In either case, navigate to a directory where compilation will take place and extract the tarball or execute: git clone https://github.com/JoeyDelp/JoSIM.git cd JoSIM Navigate to the newly cloned/extracted JoSIM directory then run the following commands: mkdir build cd build cmake .. cmake --build . --config Release This will generate a JoSIM executable in the build directory. Additionally, the libjosim library will also be generated. To use the library (and josim-cli) it needs to be PATH obtainable. The best way to do this is to do: sudo make install This option will install josim-cli and libjosim , as well as the header files needed to use it, in the relevant installation directories detected by the CMake GNUInstallDirs macro. Apple macOS Apple macOS is very similar to most Unix systems and therefore follows mostly the same procedure. The user would clone the repository and install CMake and Git. These requirements can be installed using either Homebrew, Macports or compiled from source using the standard macOS compilers (installed through Xcode). Python 3 is available through Homebrew and CMake can almost always be installed using pip (PyPI). Microsoft Windows There are various ways to compile JoSIM on the Microsoft Windows platform. The simplest way to do this is to install the Community version of Microsoft Visual Studio , which is free to use. This is only to acquire a working C++ compiler that can be used by CMake. Next Python 3 will also be needed. This can be installed using Windows Store, Anaconda or Miniconda . Once installed CMake can be installed much the same as any other system: pip install cmake - -user To ensure that CMake detects the correct compiler (a restart might be required after MSVC install) simply run: cmake - -help This should produce a help menu with a generator list at the bottom. If MSVC is installed and detected then it should have an asterisk (*) next to the relevant MSVC version to indicate that it is the default generator. The rest of the guide follows the same steps as Linux: mkdir build cd build cmake .. cmake - -build . - -config Release This will produce the JoSIM executable ( josim-cli ) and library ( josim.lib ) in the build/Release folder. Unlike Unix systems, Windows does not complete the CMake GNUInstallDirs macro correctly and if used would potentially install josim-cli in a strange location such as C:\\usr\\local\\josim\\bin\\josim-cli . It is therefore not recommended to use the install command on Windows systems but to rather copy or move the executable josim-cli to a location that is PATH obtainable under Windows. One way to do this is to create a folder under C:\\ called JoSIM , placing the josim-cli and josim.lib files from the build/Release directory inside and adding it to PATH environment by opening an elevated command prompt through Win+x key combination and choosing Command Prompt (Admin) . Type in the following command and hit enter: SETX PATH %PATH% ; C: \\J oSIM This will add the C:\\JoSIM folder to the PATH and allow josim-cli to be located through non-elevated command prompt. TimeEx and other tools Some tools, such as TimEx, require josim-cli to be named josim . Since the josim command line executable ( josim-cli ) is a singular executable, this means that there are no files that rely on its specific naming for JoSIM to function correctly. It can thus safely be renamed or copies made thereof with varying names as required by external tools (such as TimEx). Under Unix systems a symbolic link can be established through: sudo ln -s /usr/local/bin/josim-cli /usr/local/bin/josim Where the first path is the source and the second is the destination. If josim-cli is updated josim will reflect this since the symbolic link simply makes josim-cli obtainable through another name. On Windows it is best to simply rename josim-cli or to make a copy thereof with a new name. License JoSIM is governed by the MIT license, which is a very permissive license that allows anyone to redistribute the source as well as commercialize it without repercussions. The MIT license allows use of this software within proprietary software as long as all copies of the licensed software includes a copy of the MIT license as well as the copyright notice. E. S. Fang and T. Van Duzer, \"A Josephson integrated circuit simulator (JSIM) for superconductive electronics application,\" in Extended Abstracts of 1989 Intl. Superconductivity Electronics Conf. (ISEC '89) , Tokyo, Japan: JSAP, pp. 407-410, 1989 \u21a9 S. R. Whiteley, \"WRspice Circuit Simulator\" by Whiteley Research Incorporated . http://www.wrcad.com/wrspice.html \u21a9","title":"Home"},{"location":"#josim-superconducting-circuit-simulator","text":"Developers Manual for v2.5.1","title":"JoSIM - Superconducting Circuit Simulator"},{"location":"#project-status","text":"","title":"Project Status"},{"location":"#testing-v26-status","text":"","title":"Testing: v2.6 - Status:"},{"location":"#stable-v26-status","text":"","title":"Stable: v2.6 - Status:"},{"location":"#introduction","text":"JoSIM was developed under IARPA contract SuperTools(via the U.S. Army Research Office grant W911NF-17-1-0120). JoSIM is a analogue circuit simulator with SPICE syntax input that has inherent support for the superconducting Josephson junction element. JoSIM is meant to function as an alternative to the simulators such as JSIM 1 and WRspice 2 . JoSIM is written in modern C++ and is fully customizable and extendable to offer support for improved superconducting elements as well better approximations to the Josephson effect in superconducting materials. A .cir file containing a SPICE syntax circuit netlist is provided as input. The circuit netlist, given appropriate input excitations can then be simulated through transient analysis. Results of this simulation can be dumped to standard output or saved in various formats such as a comma separated value ( .csv ) file. Below is a macro overview of the process performed by JoSIM. This is very basic and is discussed in further detail in the Technical Discussion section of the documentation.","title":"Introduction"},{"location":"#project-layout","text":"The JoSIM repository has the following layout. A quick description shows the purpose of the various files and folders. cmake # CMake scripts. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. include/ JoSIM # JoSIM header files. scripts # Some Python3 scripts to automate testing and plotting site # Where this documentation spawns from. src/ ... # JoSIM source files. test # Folder containing various examples. README.md # Basic readme to get the user going. LICENSE # License that governs use of JoSIM. CMakeLists.txt # Configuration to compile code. ... # Other configuration files and scripts.","title":"Project layout"},{"location":"#initial-setup","text":"With each major version of JoSIM a release for all major platforms is generated and placed under the Releases section of the GitHub repository. At the time of writing, this is version 2.5. To compile JoSIM from source, the following packages are required: CMake 3.14 Git C++ compiler with C++17 support","title":"Initial setup"},{"location":"#building-from-source","text":"","title":"Building from source"},{"location":"#linux","text":"These instructions were executed on a minimal install of CentOS 7 to reduce oversight in the compilation instructions created by previous package installs. For other distributions please use the package manager relevant to the distribution of choice. A working internet connection is required, as well as the ability to install packages. If the internet connection is not up please run, and replace with your relevant interface i.e eth0 : sudo ifup <network interface> CentOS 7 does not contain all the enterprise Linux packages in its default repository and therefore needs to be activated using: sudo yum install epel-release sudo yum update CentOS 7 will require development packages to be installed. Fortunately this can be done using a single command: sudo yum groupinstall \"Development Tools\" This will install various development tools such as gcc , make and git . JoSIM, however, requires a newer version of gcc than the one supplied within these packages. Fortunately this can be installed fairly easily by running the following: sudo yum install centos-release-scl sudo yum install devtoolset-8 scl enable devtoolset-8 bash The last command needs to be entered whenever the newer gcc is needed. This can fortunately be shortened using an alias: echo 'alias dts8=\"scl enable devtoolset-8 bash\"' >> ~/.bashrc This will enable the devtoolset-8 environment on the current bash by just entering the command dts8 . To simplify installation of various packages we make use of Python 3 and pip: sudo install python36 python36-pip This allows installation of the most relevant package version of cmake : pip3 install cmake --user We are now ready to compile JoSIM JoSIM source can be directly downloaded from the repository as a compressed .tar.gz file or by cloning the repository. In either case, navigate to a directory where compilation will take place and extract the tarball or execute: git clone https://github.com/JoeyDelp/JoSIM.git cd JoSIM Navigate to the newly cloned/extracted JoSIM directory then run the following commands: mkdir build cd build cmake .. cmake --build . --config Release This will generate a JoSIM executable in the build directory. Additionally, the libjosim library will also be generated. To use the library (and josim-cli) it needs to be PATH obtainable. The best way to do this is to do: sudo make install This option will install josim-cli and libjosim , as well as the header files needed to use it, in the relevant installation directories detected by the CMake GNUInstallDirs macro.","title":"Linux"},{"location":"#apple-macos","text":"Apple macOS is very similar to most Unix systems and therefore follows mostly the same procedure. The user would clone the repository and install CMake and Git. These requirements can be installed using either Homebrew, Macports or compiled from source using the standard macOS compilers (installed through Xcode). Python 3 is available through Homebrew and CMake can almost always be installed using pip (PyPI).","title":"Apple macOS"},{"location":"#microsoft-windows","text":"There are various ways to compile JoSIM on the Microsoft Windows platform. The simplest way to do this is to install the Community version of Microsoft Visual Studio , which is free to use. This is only to acquire a working C++ compiler that can be used by CMake. Next Python 3 will also be needed. This can be installed using Windows Store, Anaconda or Miniconda . Once installed CMake can be installed much the same as any other system: pip install cmake - -user To ensure that CMake detects the correct compiler (a restart might be required after MSVC install) simply run: cmake - -help This should produce a help menu with a generator list at the bottom. If MSVC is installed and detected then it should have an asterisk (*) next to the relevant MSVC version to indicate that it is the default generator. The rest of the guide follows the same steps as Linux: mkdir build cd build cmake .. cmake - -build . - -config Release This will produce the JoSIM executable ( josim-cli ) and library ( josim.lib ) in the build/Release folder. Unlike Unix systems, Windows does not complete the CMake GNUInstallDirs macro correctly and if used would potentially install josim-cli in a strange location such as C:\\usr\\local\\josim\\bin\\josim-cli . It is therefore not recommended to use the install command on Windows systems but to rather copy or move the executable josim-cli to a location that is PATH obtainable under Windows. One way to do this is to create a folder under C:\\ called JoSIM , placing the josim-cli and josim.lib files from the build/Release directory inside and adding it to PATH environment by opening an elevated command prompt through Win+x key combination and choosing Command Prompt (Admin) . Type in the following command and hit enter: SETX PATH %PATH% ; C: \\J oSIM This will add the C:\\JoSIM folder to the PATH and allow josim-cli to be located through non-elevated command prompt.","title":"Microsoft Windows"},{"location":"#timeex-and-other-tools","text":"Some tools, such as TimEx, require josim-cli to be named josim . Since the josim command line executable ( josim-cli ) is a singular executable, this means that there are no files that rely on its specific naming for JoSIM to function correctly. It can thus safely be renamed or copies made thereof with varying names as required by external tools (such as TimEx). Under Unix systems a symbolic link can be established through: sudo ln -s /usr/local/bin/josim-cli /usr/local/bin/josim Where the first path is the source and the second is the destination. If josim-cli is updated josim will reflect this since the symbolic link simply makes josim-cli obtainable through another name. On Windows it is best to simply rename josim-cli or to make a copy thereof with a new name.","title":"TimeEx and other tools"},{"location":"#license","text":"JoSIM is governed by the MIT license, which is a very permissive license that allows anyone to redistribute the source as well as commercialize it without repercussions. The MIT license allows use of this software within proprietary software as long as all copies of the licensed software includes a copy of the MIT license as well as the copyright notice. E. S. Fang and T. Van Duzer, \"A Josephson integrated circuit simulator (JSIM) for superconductive electronics application,\" in Extended Abstracts of 1989 Intl. Superconductivity Electronics Conf. (ISEC '89) , Tokyo, Japan: JSAP, pp. 407-410, 1989 \u21a9 S. R. Whiteley, \"WRspice Circuit Simulator\" by Whiteley Research Incorporated . http://www.wrcad.com/wrspice.html \u21a9","title":"License"},{"location":"bugs/","text":"Development schedule and bug reporting JoSIM is an open-source project and thus relies heavily on feedback from the community. The development team consists at present of only a single person and therefore handling multiple tasks can sometimes be an issue. We request that users test the software, pushing it to its limits and reporting any bugs. Bugs will be tended to as soon as possible. JoSIM, from v2.4, adopted a more rolling release like schedule where additional features and bug fixes will be implemented in incremental updates to mitigate large scale problems with long lasting effects. Major releases will be made available on the releases page and features will be reported in the changelog, whereas minor releases will not be reported on. Please report any bugs through creating a new issue on the Issues page.","title":"Development Schedule and Bugs"},{"location":"bugs/#development-schedule-and-bug-reporting","text":"JoSIM is an open-source project and thus relies heavily on feedback from the community. The development team consists at present of only a single person and therefore handling multiple tasks can sometimes be an issue. We request that users test the software, pushing it to its limits and reporting any bugs. Bugs will be tended to as soon as possible. JoSIM, from v2.4, adopted a more rolling release like schedule where additional features and bug fixes will be implemented in incremental updates to mitigate large scale problems with long lasting effects. Major releases will be made available on the releases page and features will be reported in the changelog, whereas minor releases will not be reported on. Please report any bugs through creating a new issue on the Issues page.","title":"Development schedule and bug reporting"},{"location":"comp_stamps/","text":"Component Stamps In this section we will explore each of the available component stamps found in JoSIM. This will serve as insight into how BDF2 method is applied to produce time dependent voltage or phase equations for each component. This will serve as a continuation of what was shown in the Technical Discussion section for the Capacitor. Resistor A resistor is a passive circuit element for which the voltage dependent equation is defined through Ohm's law: \\[ v(t) = i_{R_{1}}(t) R_{1} \\] \\[ V_{n}-R_{1}I_{R_{1}} = 0 \\] This can then be written as a matrix stamp in the form \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -R_{1} \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-}\\\\ I_{R_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0 \\end{bmatrix} \\] If we expand this using the voltage-phase relation shown in Technical Discussion , then we can rewrite the equation as: \\[ \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}_{n}\\frac{1}{R_{1}} = I_{R_{1}} \\] This equation will now require the application of the BDF2 method: \\[ \\frac{\\Phi_{0}}{2\\pi R_{1}}\\frac{3}{2h}\\left[\\phi_n - \\frac{4}{3}\\phi_{n-1} + \\frac{1}{3}\\phi_{n\u22122}\\right] = {I_{R_{1}}} \\] \\[ \\phi_n - \\frac{2\\pi R_{1}}{\\Phi_0}\\frac{2h}{3}I_{R_{1}} =\\frac{4}{3}\\phi_{n-1} - \\frac{1}{3}\\phi_{n\u22122} \\] This allows us to create a phase resistor matrix stamp as: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{2\\pi R_{1}}{\\Phi_0}\\frac{2h}{3} \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{R_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\frac{4}{3}\\phi_{n-1} - \\frac{1}{3}\\phi_{n\u22122} \\end{bmatrix} \\] Inductor A inductor is defined in terms of voltage and current as: \\[ v(t)=L_{1}\\frac{di}{dt} \\] This is a first order differential and needs to be expanded using the BDF2 method: \\[ V_{n} = \\frac{3L_{1}}{2h}\\left[I_{n}-\\frac{4}{3}I_{n-1}+\\frac{1}{3}I_{n-2}\\right] \\] \\[ V_{n}-\\frac{3L_{1}}{2h}I_{n}=-\\frac{2L_{1}}{h}I_{n-1}+\\frac{L_{1}}{2h}I_{n-2} \\] This allows us to create the inductor stamp as: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{3L_{1}}{2h} \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ I_{L_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -\\frac{2L_{1}}{h}I_{n-1}+\\frac{L_{1}}{2h}I_{n-2} \\end{bmatrix} \\] The MNPA stamp for the inductor is derived by substituting the voltage-phase relation. \\[ \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}=L_{1}\\frac{di}{dt} \\] With derivatives on both sides, we can integrate with respect to time on both sides: \\[ \\int\\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}=\\int L_{1}\\frac{di}{dt} \\] \\[ \\frac{\\Phi_{0}}{2\\pi}\\phi_{n}=L_{1}I_{n} \\] \\[ \\phi_{n} - \\frac{2\\pi}{\\Phi_{0}}L_{1}I_{n} = 0 \\] Which leads to the extremely simplistic inductor MNPA stamp matrix: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{2\\pi}{\\Phi_{0}}L_{1} \\end{bmatrix} \\begin{bmatrix} \\phi^{+} \\\\ \\phi^{-} \\\\ I_{L_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ 0 \\end{bmatrix} \\] Josephson Junction The Josephson junction above is a simplification of the resistively and capacitively shunted junction (RCSJ) model implemented in JoSIM. This model sums the current through the 3 parallel branches and is represented by the following equation: \\[ I_{B_{1}} = I_c \\sin{\\phi} + \\frac{V_{n}}{R_{B_{1}}} + C_{B_{1}}\\frac{dV_{n}}{dt} \\] Which when expanded with the BDF2 method becomes: \\[ I_{B_{1}} = I_{c}\\sin\\phi+\\frac{V_{n}}{R_{B_{1}}}+\\frac{3C_{B_{1}}}{2h}\\left[V_{n}-\\frac{4}{3}V_{n-1}+\\frac{1}{3}V_{n-2}\\right] \\] \\[ \\frac{V_{n}}{R_{B_{1}}}+ \\frac{3C_{B_{1}}}{2h}V_{n} - I_{B_{1}} = -I_{c}\\sin\\phi+\\frac{3C_{B_{1}}}{2h}\\frac{4}{3}V_{n-1}-\\frac{3C_{B_{1}}}{2h}\\frac{1}{3}V_{n-2} \\] \\[ V_{n}-\\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}}I_{B_{1}}=\\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}}\\left[I_{c}\\sin\\phi-\\frac{2C_{B_{1}}}{h}V_{n-1}+\\frac{C_{B_{1}}}{2h}V_{n-2}\\right] \\] This equation depends on the phase at the present time step, which needs to be solved. Phase is not, however, solved and we therefore need to use the voltage-phase relationship to find a voltage dependent solution for the phase: \\[ V_{n} = \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi}{dt}}_{n} \\] \\[ V_{n} = \\frac{\\Phi_{0}}{2\\pi}\\frac{3}{2h}\\left[\\phi_{n}-\\frac{4}{3}\\phi_{n-1}+\\frac{1}{3}\\phi_{n-2}\\right] \\] \\[ V_{n}-\\frac{\\Phi_{0}}{2\\pi}\\frac{3}{2h}\\phi_n=-\\frac{\\Phi_{0}}{2\\pi}\\frac{2}{h}\\phi_{n-1}+\\frac{\\Phi_{0}}{2\\pi}\\frac{1}{h}\\phi_{n-2} \\] We can now combine these two equations to form the component stamp matrix: \\[ \\begin{bmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{\\Phi_{0}}{2\\pi}\\frac{3}{2h} & 0 \\\\ 1 & -1 & 0 & -\\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}} \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ \\phi_{n}\\\\ I_{B_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -\\frac{\\Phi_{0}}{2\\pi}\\frac{2}{h}\\phi_{n-1}+\\frac{\\Phi_{0}}{2\\pi}\\frac{1}{h}\\phi_{n-2} \\\\ I_{s} \\end{bmatrix} \\] Where \\(I_{s} = \\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}}\\left[I_{c}\\sin\\phi-\\frac{2C_{B_{1}}}{h}V_{n-1}+\\frac{C_{B_{1}}}{2h}V_{n-2}\\right]\\) It is, however, not possible to use the phase value for the current time step in the calculation of the current time step, we therefore have to rely on an estimated phase value based on previous values. We define this estimation as: \\[ \\phi_{n}^{0} =\\frac{4}{3}\\phi_{n-1}-\\frac{1}{3}\\phi_{n-2}+ \\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}V_{n}^{0} \\] \\[ V_{n}^{0} = V_{n-1} + h\\frac{dV}{dt}_{n-1} \\] \\[ V_{n}^{0}=V_{n-1}+\\frac{3}{2}V_{n-1}-2V_{n-2}+\\frac{1}{2}V_{n-3} \\] \\[ V_{n}^{0}=\\frac{5}{2}V_{n-1}-2V_{n-2}+\\frac{1}{2}V_{n-3} \\] The current phase case is rather basic and we therefore replace the supercurrent term with the more general term defined by Haberkorn 1 : \\[ I_c\\sin\\phi = \\frac{\\pi\\Delta}{2eR_N}\\frac{\\sin{\\phi}}{\\sqrt{1 - \\overline{D}\\sin^2\\left(\\frac{\\phi}{2}\\right)}}\\tanh\\left[\\frac{\\Delta}{2k_BT}\\sqrt{1-\\overline{D}\\sin^2\\left(\\frac{\\phi}{2}\\right)}\\right] \\] This equation introduces temperature dependence within the junction model through \\(\\Delta\\) : \\[ \\Delta_0 = 1.76k_BT_c\u200b \\] \\[ \\Delta = \\Delta_0\\sqrt{\\cos\\left[\\frac{\\pi}{2}\\left(\\frac{T}{T_c}\\right)^2\\right]} \\] with \\(T\\) , the boiling point of liquid Helium (4.2K), \\(T_{c}\\) the critical temperature of Niobium (9.1K) and \\(k_{B}\\) is Boltzmann's constant for average kinetic energy of particles. The resistance value \\(R_{N}\\) is defined as: \\[ R_N = \\frac{\\pi\\Delta}{2eI_c}\\tanh\\left(\\frac{\\Delta}{2k_{B}T}\\right) \\] This allows us to change the characteristics of the tunnel current by simply altering the transparency value \\(\\overline{D}\\) . For values of \\(\\overline{D} \\ll 1\\) the equation becomes the normal sinusoidal equation whereas for large values of \\(\\overline{D}\\) it becomes the non-sinusoidal ballistic tunneling equation. To define the Josephson junction in phase we simply swap the voltage and phase of the component previously identified. The equations remain mostly the same since the Josephson junction is already a phase element. \\[ \\begin{bmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3} & 0 \\\\ 0 & 0 & 1 & -\\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}} \\end{bmatrix} \\begin{bmatrix} \\phi^{+} \\\\ \\phi^{-} \\\\ V_{n}\\\\ I_{B_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{4}{3}\\phi_{n-1} - \\frac{1}{3}\\phi_{n-2} \\\\ I_{s} \\end{bmatrix} \\] Voltage Source A voltage source is nothing more than is implied. It is a source of voltage, this indicates that the voltage at any time step is known. We can therefore easily create a component stamp matrix in the form: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ I_{V_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ V_{1} \\end{bmatrix} \\] The phase version of this element simply sees the voltage replaced with the voltage-phase relation: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} \\phi_{+} \\\\ \\phi_{-} \\\\ I_{V_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\frac{4}{3}\\phi_{n-1}-\\frac{1}{3}\\phi_{n-2}+ \\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}V_{n} \\end{bmatrix} \\] Current Source A current source is, as implied, a current that is known at every time step in the simulation. It can therefore simply be applied where needed on the RHS. \\[ \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\end{bmatrix} = \\begin{bmatrix} -I_{1}\\\\ I_{1} \\end{bmatrix} \\] Phase Source Like a voltage source, simply applies a phase where needed within the circuit. \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} \\phi^{+} \\\\ \\phi^{-} \\\\ I_{\\phi} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\phi_{n} \\end{bmatrix} \\] When voltage mode is used for analysis, this device transforms into a voltage source with the following stamp: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ I_{\\phi} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\frac{\\Phi_{0}}{2\\pi}\\frac{3}{2h}\\left[\\phi_{n}-\\frac{4}{3}\\phi_{n-1}+\\frac{1}{3}\\phi_{n-2}\\right] \\end{bmatrix} \\] Transmission Line A transmission line is, at present, simply a delay element where the delay ( \\(T_{D}\\) ) and impedance ( \\(Z_{0}\\) ) define the length of the transmission line. At present we model the transmission line as an ideal element without any losses. We will in future implement a more accurate model of the transmission line. The equations that govern this lossless transmission line are: \\[ V_1(t) = Z_{0}I_{T_{1}} + Z_{0}I_{T_{2}}(t \u2212 T_{D}) + V_2(t \u2212 T_{D}) \\] \\[ V_2(t) = Z_{0}I_{T_{2}} + Z_{0}I_{T_{1}}(t \u2212 T_{D}) + V_1(t \u2212 T_{D}) \\] which leads to \\[ (V_{1})_{n} - Z_{0}(I_{T_{1}})_{n} = Z_{0}(I_{T_{2}})_{n-k} + (V_{2})_{n-k} \\] \\[ (V_{2})_{n} - Z_{0}(I_{T_{2}})_{n} = Z_{0}(I_{T_{1}})_{n-k} + (V_{1})_{n-k} \\] where \\[ k=\\frac{T_D}{h} \\] Which allows us to create a component stamp matrix \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -Z_{0} & 0 \\\\ 0 & 0 & 1 & -1 & 0 & -Z_{0} \\end{bmatrix} \\begin{bmatrix} V_{1}^{+} \\\\ V_{1}^{-} \\\\ V_{2}^{+} \\\\ V_{2}^{-} \\\\ I_{T_{1}} \\\\ I_{T_{2}} \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ Z_{0}(I_{T_{2}})_{n-k} + (V_{2})_{n-k} \\\\ Z_{0}(I_{T_{1}})_{n-k} + (V_{1})_{n-k} \\end{bmatrix} \\] We only expand the first equation of the transmission line in phase for simplicity: \\[ \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi_{1}}{dt} = Z_{0}(I_{T_{1}})_{n} + Z_{0}(I_{T_{2}})_{n-k} + \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi_2}{dt}_{n-k} \\] \\[ \\frac{\\Phi_{0}}{2\\pi}\\left[\\frac{3}{2h}(\\phi_{1})_{n} - \\frac{2}{h}(\\phi_{1})_{n-1} + \\frac{1}{2h}{\\phi_{1}}_{n-2}\\right] = Z_{0}(I_{T_{1}})_{n} + Z_{0}(I_{T_{2}})_{n-k} + \\frac{\\Phi_{0}}{2\\pi}\\left[\\frac{3}{2h}(\\phi_{2})_{n-k} - \\frac{2}{h}(\\phi_{2})_{n-k-1} + \\frac{1}{2h}(\\phi_{2})_{n-k-2}\\right] \\] \\[ \\frac{3}{2h}(\\phi_{1})_{n} - \\frac{2}{h}(\\phi_{1})_{n-1} + \\frac{1}{2h}(\\phi_{1})_{n-2} = \\frac{2\\pi}{\\Phi_{0}}Z_{0}(I_{T_{1}})_{n} + \\frac{2\\pi}{\\Phi_{0}}Z_{0}(I_{T_{2}})_{n-k} + \\frac{3}{2h}(\\phi_{2})_{n-k} - \\frac{2}{h}(\\phi_{2})_{n-k-1} + \\frac{1}{2h}(\\phi_{2})_{n-k-2} \\] \\[ (\\phi_{1})_{n} - \\frac{2h}{3}\\frac{2}{h}(\\phi_{1})_{n-1} + \\frac{2h}{3}\\frac{1}{2h}(\\phi_{1})_{n-2} = \\frac{2h}{3}\\frac{2\\pi}{\\Phi_{0}}Z_{0}(I_{T_{1}})_{n} + \\frac{2h}{3}\\frac{2\\pi}{\\Phi_{0}}Z_{0}(I_{T_{2}})_{n-k} + \\frac{2h}{3}\\frac{3}{2h}(\\phi_{2})_{n-k} - \\frac{2h}{3}\\frac{2}{h}(\\phi_{2})_{n-k-1} + \\frac{2h}{3}\\frac{1}{2h}(\\phi_{2})_{n-k-2} \\] \\[ (\\phi_{1})_{n} - \\frac{4}{3}(\\phi_{1})_{n-1} + \\frac{1}{3}(\\phi_{1})_{n-2} = \\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}Z_{0}(I_{T_{1}})_{n} + \\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}Z_{0}(I_{T_{2}})_{n-k} + (\\phi_{2})_{n-k} - \\frac{4}{3}(\\phi_{2})_{n-k-1} + \\frac{1}{3}(\\phi_{2})_{n-k-2} \\\\ \\] Simplifying this equation results in: \\[ (\\phi_{1})_n - Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}(I_{T_{1}})_{n} = Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}{I_{T_{2}}}_{n-k} + \\frac{4}{3}(\\phi_{1})_{n-1} - \\frac{1}{3}(\\phi_{1})_{n-2} + (\\phi_{2})_{n-k} - \\frac{4}{3}(\\phi_{2})_{n-k-1} + \\frac{1}{3}(\\phi_{2})_{n-k-2} \\] \\[ (\\phi_{2})_n - Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}(I_{T_{2}})_{n} = Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}{I_{T_{1}}}_{n-k} + \\frac{4}{3}(\\phi_{2})_{n-1} - \\frac{1}{3}(\\phi_{2})_{n-2} + (\\phi_{1})_{n-k} - \\frac{4}{3}(\\phi_{1})_{n-k-1} + \\frac{1}{3}(\\phi_{1})_{n-k-2} \\] This leads to the component stamp matrix: \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & - Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3} & 0 \\\\ 0 & 0 & 1 & -1 & 0 & - Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3} \\end{bmatrix} \\begin{bmatrix} \\phi_{1}^{+} \\\\ \\phi_{1}^{-} \\\\ \\phi_{2}^{+} \\\\ \\phi_{2}^{-} \\\\ I_{T_{1}} \\\\ I_{T_{2}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ 0 \\\\ 0 \\\\ V_{T_{1}} \\\\ V_{T_{2}} \\end{bmatrix} \\] With \\(V_{T_{1}}\\) and \\(V_{T_{2}}\\) the RHS of the expanded equations above. Mutual inductance Mutual inductance allows simulation of coupling between inductors. This coupling adds an additional term to the inductor equation: \\[ v_{L_{1}}(t) = L1 \\frac{di_{1}(t)}{dt} + M\\frac{di_{2}(t)}{dt} \\] \\[ v_{L_{2}}(t) = L2 \\frac{di_{2}(t)}{dt} + M\\frac{di_{1}(t)}{dt} \\] with \\[ M = k\\sqrt{L_{1} L_{2}} \\] We expand these equations to: \\[ \\left(V_{L_{1}}\\right)_n - \\frac{3L_{1}}{2h}\\left(I_{L_{1}}\\right)_n - \\frac{3M}{2h}\\left(I_{L_{2}}\\right)_n = - \\frac{2L_{1}}{h}\\left(I_{L_{1}}\\right)_{n-1} + \\frac{L_{1}}{2h}\\left(I_{L_{1}}\\right)_{n-2} - \\frac{2M}{h}\\left(I_{L_{2}}\\right)_{n-1} + \\frac{M}{2h}\\left(I_{L_{2}}\\right)_{n-2} \\] \\[ \\left(V_{L_{2}}\\right)_n - \\frac{3L_{2}}{2h}\\left(I_{L_{2}}\\right)_n - \\frac{3M}{2h}\\left(I_{L_{1}}\\right)_n = - \\frac{2L_{2}}{h}\\left(I_{L_{2}}\\right)_{n-1} + \\frac{L_{2}}{2h}\\left(I_{L_{2}}\\right)_{n-2} - \\frac{2M}{h}\\left(I_{L_{1}}\\right)_{n-1} + \\frac{M}{2h}\\left(I_{L_{1}}\\right)_{n-2} \\] This leads to the component stamp matrix: \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & - \\frac{3L_{1}}{2h} & - \\frac{3M}{2h} \\\\ 0 & 0 & 1 & -1 & - \\frac{3M}{2h} & - \\frac{3L_{2}}{2h} \\\\ \\end{bmatrix} \\begin{bmatrix} V_{L_{1}}^{+} \\\\ V_{L_{1}}^{-} \\\\ V_{L_{2}}^{+} \\\\ V_{L_{2}}^{-} \\\\ I_{L_{1}} \\\\ I_{L_{2}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ - \\frac{2L_{1}}{h}\\left(I_{L_{1}}\\right)_{n-1} + \\frac{L_{1}}{2h}\\left(I_{L_{1}}\\right)_{n-2} - \\frac{2M}{h}\\left(I_{L_{2}}\\right)_{n-1} + \\frac{M}{2h}\\left(I_{L_{2}}\\right)_{n-2} \\\\ - \\frac{2L_{2}}{h}\\left(I_{L_{2}}\\right)_{n-1} + \\frac{L_{2}}{2h}\\left(I_{L_{2}}\\right)_{n-2} - \\frac{2M}{h}\\left(I_{L_{1}}\\right)_{n-1} + \\frac{M}{2h}\\left(I_{L_{1}}\\right)_{n-2} \\end{bmatrix} \\] The phase variant of this \\[ \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{L_{1}}}{dt} = L_{1}\\frac{di_{L_{1}}}{dt} + M\\frac{di_{L_{2}}}{dt} \\] \\[ \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{L_{2}}}{dt} =M\\frac{di_{L_{1}}}{dt} + L_{2}\\frac{di_{L_{2}}}{dt} \\] With integration on both sides \\[ \\frac{\\Phi_0}{2\\pi}\\phi_{L_{1}} = L_{1}I_{L_{1}} + MI_{L_{2}} \\] \\[ \\frac{\\Phi_0}{2\\pi}\\phi_{L_{2}} = MI_{L_{1}} + L_{2}I_{L_{2}} \\] This leads to a quite simplified component stamp matrix \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -\\frac{2\\pi}{\\Phi_0}L_{1} & -\\frac{2\\pi}{\\Phi_0}M \\\\ 0 & 0 & 1 & -1 & -\\frac{2\\pi}{\\Phi_0}M & -\\frac{2\\pi}{\\Phi_0}L_{2} \\\\ \\end{bmatrix} \\begin{bmatrix} \\phi_{L_{1}}^{+} \\\\ \\phi_{L_{1}}^{-} \\\\ \\phi_{L_{2}}^{+} \\\\ \\phi_{L_{2}}^{-} \\\\ I_{L_{1}} \\\\ I_{L_{2}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} \\] Current Controlled Current Source Current controlled current source allows modulation of current in a particular branch through the current in a remote branch. \\[ I_{out} = \\beta I_{in} \\] \\[ V_{1} - V_{2} = 0 \\] \\[ \\beta = value \\] \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & \\frac{1}{\\beta} \\\\ 0 & 0 & 0 & 0 & -\\frac{1}{\\beta} \\\\ 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{out} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\] Current Controlled Voltage Source Current controlled voltage source allows the modulation of a voltage node through a remote current. \\[ V_{1} - V_{2} = 0 \\] \\[ V_{3} - V_{4} = \\mu I_{in} \\] \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 0 & -1 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & 0 & -1\\\\ 0 & 0 & 1 & -1 & -\\mu & 0\\\\ 1 & -1 & 0 & 0 & 0 & -\\mu \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{in}\\\\ I_{out}\\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\] Voltage Controlled Current Source Voltage controlled current source allows the modulation of a current in a branch through a remote voltage. \\[ \\alpha(V_{1} - V_{2}) = I_{out} \\] \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & -1\\\\ 1 & -1 & 0 & 0 & -\\frac{1}{\\alpha} \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{in} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\] Voltage Controlled Voltage Source Voltage controlled current source allows the modulation of a current in a branch through a remote voltage. \\[ A(V_{1} - V_{2}) = V_{3}-V_{4} \\] \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & -1\\\\ G & -G & 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{out} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\] W. Haberkorn, H. Knauer and J. Richter, \"A theoretical study of the current-phase relation in Josephson contacts\" in physica status solidi (a) , vol. 47, no. 2, pp. K161-K164, 1978 \u21a9","title":"Component Stamps"},{"location":"comp_stamps/#component-stamps","text":"In this section we will explore each of the available component stamps found in JoSIM. This will serve as insight into how BDF2 method is applied to produce time dependent voltage or phase equations for each component. This will serve as a continuation of what was shown in the Technical Discussion section for the Capacitor.","title":"Component Stamps"},{"location":"comp_stamps/#resistor","text":"A resistor is a passive circuit element for which the voltage dependent equation is defined through Ohm's law: \\[ v(t) = i_{R_{1}}(t) R_{1} \\] \\[ V_{n}-R_{1}I_{R_{1}} = 0 \\] This can then be written as a matrix stamp in the form \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -R_{1} \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-}\\\\ I_{R_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0 \\end{bmatrix} \\] If we expand this using the voltage-phase relation shown in Technical Discussion , then we can rewrite the equation as: \\[ \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}_{n}\\frac{1}{R_{1}} = I_{R_{1}} \\] This equation will now require the application of the BDF2 method: \\[ \\frac{\\Phi_{0}}{2\\pi R_{1}}\\frac{3}{2h}\\left[\\phi_n - \\frac{4}{3}\\phi_{n-1} + \\frac{1}{3}\\phi_{n\u22122}\\right] = {I_{R_{1}}} \\] \\[ \\phi_n - \\frac{2\\pi R_{1}}{\\Phi_0}\\frac{2h}{3}I_{R_{1}} =\\frac{4}{3}\\phi_{n-1} - \\frac{1}{3}\\phi_{n\u22122} \\] This allows us to create a phase resistor matrix stamp as: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{2\\pi R_{1}}{\\Phi_0}\\frac{2h}{3} \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{R_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\frac{4}{3}\\phi_{n-1} - \\frac{1}{3}\\phi_{n\u22122} \\end{bmatrix} \\]","title":"Resistor"},{"location":"comp_stamps/#inductor","text":"A inductor is defined in terms of voltage and current as: \\[ v(t)=L_{1}\\frac{di}{dt} \\] This is a first order differential and needs to be expanded using the BDF2 method: \\[ V_{n} = \\frac{3L_{1}}{2h}\\left[I_{n}-\\frac{4}{3}I_{n-1}+\\frac{1}{3}I_{n-2}\\right] \\] \\[ V_{n}-\\frac{3L_{1}}{2h}I_{n}=-\\frac{2L_{1}}{h}I_{n-1}+\\frac{L_{1}}{2h}I_{n-2} \\] This allows us to create the inductor stamp as: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{3L_{1}}{2h} \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ I_{L_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -\\frac{2L_{1}}{h}I_{n-1}+\\frac{L_{1}}{2h}I_{n-2} \\end{bmatrix} \\] The MNPA stamp for the inductor is derived by substituting the voltage-phase relation. \\[ \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}=L_{1}\\frac{di}{dt} \\] With derivatives on both sides, we can integrate with respect to time on both sides: \\[ \\int\\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}=\\int L_{1}\\frac{di}{dt} \\] \\[ \\frac{\\Phi_{0}}{2\\pi}\\phi_{n}=L_{1}I_{n} \\] \\[ \\phi_{n} - \\frac{2\\pi}{\\Phi_{0}}L_{1}I_{n} = 0 \\] Which leads to the extremely simplistic inductor MNPA stamp matrix: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{2\\pi}{\\Phi_{0}}L_{1} \\end{bmatrix} \\begin{bmatrix} \\phi^{+} \\\\ \\phi^{-} \\\\ I_{L_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ 0 \\end{bmatrix} \\]","title":"Inductor"},{"location":"comp_stamps/#josephson-junction","text":"The Josephson junction above is a simplification of the resistively and capacitively shunted junction (RCSJ) model implemented in JoSIM. This model sums the current through the 3 parallel branches and is represented by the following equation: \\[ I_{B_{1}} = I_c \\sin{\\phi} + \\frac{V_{n}}{R_{B_{1}}} + C_{B_{1}}\\frac{dV_{n}}{dt} \\] Which when expanded with the BDF2 method becomes: \\[ I_{B_{1}} = I_{c}\\sin\\phi+\\frac{V_{n}}{R_{B_{1}}}+\\frac{3C_{B_{1}}}{2h}\\left[V_{n}-\\frac{4}{3}V_{n-1}+\\frac{1}{3}V_{n-2}\\right] \\] \\[ \\frac{V_{n}}{R_{B_{1}}}+ \\frac{3C_{B_{1}}}{2h}V_{n} - I_{B_{1}} = -I_{c}\\sin\\phi+\\frac{3C_{B_{1}}}{2h}\\frac{4}{3}V_{n-1}-\\frac{3C_{B_{1}}}{2h}\\frac{1}{3}V_{n-2} \\] \\[ V_{n}-\\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}}I_{B_{1}}=\\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}}\\left[I_{c}\\sin\\phi-\\frac{2C_{B_{1}}}{h}V_{n-1}+\\frac{C_{B_{1}}}{2h}V_{n-2}\\right] \\] This equation depends on the phase at the present time step, which needs to be solved. Phase is not, however, solved and we therefore need to use the voltage-phase relationship to find a voltage dependent solution for the phase: \\[ V_{n} = \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi}{dt}}_{n} \\] \\[ V_{n} = \\frac{\\Phi_{0}}{2\\pi}\\frac{3}{2h}\\left[\\phi_{n}-\\frac{4}{3}\\phi_{n-1}+\\frac{1}{3}\\phi_{n-2}\\right] \\] \\[ V_{n}-\\frac{\\Phi_{0}}{2\\pi}\\frac{3}{2h}\\phi_n=-\\frac{\\Phi_{0}}{2\\pi}\\frac{2}{h}\\phi_{n-1}+\\frac{\\Phi_{0}}{2\\pi}\\frac{1}{h}\\phi_{n-2} \\] We can now combine these two equations to form the component stamp matrix: \\[ \\begin{bmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{\\Phi_{0}}{2\\pi}\\frac{3}{2h} & 0 \\\\ 1 & -1 & 0 & -\\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}} \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ \\phi_{n}\\\\ I_{B_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -\\frac{\\Phi_{0}}{2\\pi}\\frac{2}{h}\\phi_{n-1}+\\frac{\\Phi_{0}}{2\\pi}\\frac{1}{h}\\phi_{n-2} \\\\ I_{s} \\end{bmatrix} \\] Where \\(I_{s} = \\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}}\\left[I_{c}\\sin\\phi-\\frac{2C_{B_{1}}}{h}V_{n-1}+\\frac{C_{B_{1}}}{2h}V_{n-2}\\right]\\) It is, however, not possible to use the phase value for the current time step in the calculation of the current time step, we therefore have to rely on an estimated phase value based on previous values. We define this estimation as: \\[ \\phi_{n}^{0} =\\frac{4}{3}\\phi_{n-1}-\\frac{1}{3}\\phi_{n-2}+ \\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}V_{n}^{0} \\] \\[ V_{n}^{0} = V_{n-1} + h\\frac{dV}{dt}_{n-1} \\] \\[ V_{n}^{0}=V_{n-1}+\\frac{3}{2}V_{n-1}-2V_{n-2}+\\frac{1}{2}V_{n-3} \\] \\[ V_{n}^{0}=\\frac{5}{2}V_{n-1}-2V_{n-2}+\\frac{1}{2}V_{n-3} \\] The current phase case is rather basic and we therefore replace the supercurrent term with the more general term defined by Haberkorn 1 : \\[ I_c\\sin\\phi = \\frac{\\pi\\Delta}{2eR_N}\\frac{\\sin{\\phi}}{\\sqrt{1 - \\overline{D}\\sin^2\\left(\\frac{\\phi}{2}\\right)}}\\tanh\\left[\\frac{\\Delta}{2k_BT}\\sqrt{1-\\overline{D}\\sin^2\\left(\\frac{\\phi}{2}\\right)}\\right] \\] This equation introduces temperature dependence within the junction model through \\(\\Delta\\) : \\[ \\Delta_0 = 1.76k_BT_c\u200b \\] \\[ \\Delta = \\Delta_0\\sqrt{\\cos\\left[\\frac{\\pi}{2}\\left(\\frac{T}{T_c}\\right)^2\\right]} \\] with \\(T\\) , the boiling point of liquid Helium (4.2K), \\(T_{c}\\) the critical temperature of Niobium (9.1K) and \\(k_{B}\\) is Boltzmann's constant for average kinetic energy of particles. The resistance value \\(R_{N}\\) is defined as: \\[ R_N = \\frac{\\pi\\Delta}{2eI_c}\\tanh\\left(\\frac{\\Delta}{2k_{B}T}\\right) \\] This allows us to change the characteristics of the tunnel current by simply altering the transparency value \\(\\overline{D}\\) . For values of \\(\\overline{D} \\ll 1\\) the equation becomes the normal sinusoidal equation whereas for large values of \\(\\overline{D}\\) it becomes the non-sinusoidal ballistic tunneling equation. To define the Josephson junction in phase we simply swap the voltage and phase of the component previously identified. The equations remain mostly the same since the Josephson junction is already a phase element. \\[ \\begin{bmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3} & 0 \\\\ 0 & 0 & 1 & -\\frac{2hR_{B_{1}}}{2h+3C_{B_{1}}R_{B_{1}}} \\end{bmatrix} \\begin{bmatrix} \\phi^{+} \\\\ \\phi^{-} \\\\ V_{n}\\\\ I_{B_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{4}{3}\\phi_{n-1} - \\frac{1}{3}\\phi_{n-2} \\\\ I_{s} \\end{bmatrix} \\]","title":"Josephson Junction"},{"location":"comp_stamps/#voltage-source","text":"A voltage source is nothing more than is implied. It is a source of voltage, this indicates that the voltage at any time step is known. We can therefore easily create a component stamp matrix in the form: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ I_{V_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ V_{1} \\end{bmatrix} \\] The phase version of this element simply sees the voltage replaced with the voltage-phase relation: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} \\phi_{+} \\\\ \\phi_{-} \\\\ I_{V_{1}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\frac{4}{3}\\phi_{n-1}-\\frac{1}{3}\\phi_{n-2}+ \\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}V_{n} \\end{bmatrix} \\]","title":"Voltage Source"},{"location":"comp_stamps/#current-source","text":"A current source is, as implied, a current that is known at every time step in the simulation. It can therefore simply be applied where needed on the RHS. \\[ \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\end{bmatrix} = \\begin{bmatrix} -I_{1}\\\\ I_{1} \\end{bmatrix} \\]","title":"Current Source"},{"location":"comp_stamps/#phase-source","text":"Like a voltage source, simply applies a phase where needed within the circuit. \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} \\phi^{+} \\\\ \\phi^{-} \\\\ I_{\\phi} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\phi_{n} \\end{bmatrix} \\] When voltage mode is used for analysis, this device transforms into a voltage source with the following stamp: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ I_{\\phi} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\frac{\\Phi_{0}}{2\\pi}\\frac{3}{2h}\\left[\\phi_{n}-\\frac{4}{3}\\phi_{n-1}+\\frac{1}{3}\\phi_{n-2}\\right] \\end{bmatrix} \\]","title":"Phase Source"},{"location":"comp_stamps/#transmission-line","text":"A transmission line is, at present, simply a delay element where the delay ( \\(T_{D}\\) ) and impedance ( \\(Z_{0}\\) ) define the length of the transmission line. At present we model the transmission line as an ideal element without any losses. We will in future implement a more accurate model of the transmission line. The equations that govern this lossless transmission line are: \\[ V_1(t) = Z_{0}I_{T_{1}} + Z_{0}I_{T_{2}}(t \u2212 T_{D}) + V_2(t \u2212 T_{D}) \\] \\[ V_2(t) = Z_{0}I_{T_{2}} + Z_{0}I_{T_{1}}(t \u2212 T_{D}) + V_1(t \u2212 T_{D}) \\] which leads to \\[ (V_{1})_{n} - Z_{0}(I_{T_{1}})_{n} = Z_{0}(I_{T_{2}})_{n-k} + (V_{2})_{n-k} \\] \\[ (V_{2})_{n} - Z_{0}(I_{T_{2}})_{n} = Z_{0}(I_{T_{1}})_{n-k} + (V_{1})_{n-k} \\] where \\[ k=\\frac{T_D}{h} \\] Which allows us to create a component stamp matrix \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -Z_{0} & 0 \\\\ 0 & 0 & 1 & -1 & 0 & -Z_{0} \\end{bmatrix} \\begin{bmatrix} V_{1}^{+} \\\\ V_{1}^{-} \\\\ V_{2}^{+} \\\\ V_{2}^{-} \\\\ I_{T_{1}} \\\\ I_{T_{2}} \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ Z_{0}(I_{T_{2}})_{n-k} + (V_{2})_{n-k} \\\\ Z_{0}(I_{T_{1}})_{n-k} + (V_{1})_{n-k} \\end{bmatrix} \\] We only expand the first equation of the transmission line in phase for simplicity: \\[ \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi_{1}}{dt} = Z_{0}(I_{T_{1}})_{n} + Z_{0}(I_{T_{2}})_{n-k} + \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi_2}{dt}_{n-k} \\] \\[ \\frac{\\Phi_{0}}{2\\pi}\\left[\\frac{3}{2h}(\\phi_{1})_{n} - \\frac{2}{h}(\\phi_{1})_{n-1} + \\frac{1}{2h}{\\phi_{1}}_{n-2}\\right] = Z_{0}(I_{T_{1}})_{n} + Z_{0}(I_{T_{2}})_{n-k} + \\frac{\\Phi_{0}}{2\\pi}\\left[\\frac{3}{2h}(\\phi_{2})_{n-k} - \\frac{2}{h}(\\phi_{2})_{n-k-1} + \\frac{1}{2h}(\\phi_{2})_{n-k-2}\\right] \\] \\[ \\frac{3}{2h}(\\phi_{1})_{n} - \\frac{2}{h}(\\phi_{1})_{n-1} + \\frac{1}{2h}(\\phi_{1})_{n-2} = \\frac{2\\pi}{\\Phi_{0}}Z_{0}(I_{T_{1}})_{n} + \\frac{2\\pi}{\\Phi_{0}}Z_{0}(I_{T_{2}})_{n-k} + \\frac{3}{2h}(\\phi_{2})_{n-k} - \\frac{2}{h}(\\phi_{2})_{n-k-1} + \\frac{1}{2h}(\\phi_{2})_{n-k-2} \\] \\[ (\\phi_{1})_{n} - \\frac{2h}{3}\\frac{2}{h}(\\phi_{1})_{n-1} + \\frac{2h}{3}\\frac{1}{2h}(\\phi_{1})_{n-2} = \\frac{2h}{3}\\frac{2\\pi}{\\Phi_{0}}Z_{0}(I_{T_{1}})_{n} + \\frac{2h}{3}\\frac{2\\pi}{\\Phi_{0}}Z_{0}(I_{T_{2}})_{n-k} + \\frac{2h}{3}\\frac{3}{2h}(\\phi_{2})_{n-k} - \\frac{2h}{3}\\frac{2}{h}(\\phi_{2})_{n-k-1} + \\frac{2h}{3}\\frac{1}{2h}(\\phi_{2})_{n-k-2} \\] \\[ (\\phi_{1})_{n} - \\frac{4}{3}(\\phi_{1})_{n-1} + \\frac{1}{3}(\\phi_{1})_{n-2} = \\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}Z_{0}(I_{T_{1}})_{n} + \\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}Z_{0}(I_{T_{2}})_{n-k} + (\\phi_{2})_{n-k} - \\frac{4}{3}(\\phi_{2})_{n-k-1} + \\frac{1}{3}(\\phi_{2})_{n-k-2} \\\\ \\] Simplifying this equation results in: \\[ (\\phi_{1})_n - Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}(I_{T_{1}})_{n} = Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}{I_{T_{2}}}_{n-k} + \\frac{4}{3}(\\phi_{1})_{n-1} - \\frac{1}{3}(\\phi_{1})_{n-2} + (\\phi_{2})_{n-k} - \\frac{4}{3}(\\phi_{2})_{n-k-1} + \\frac{1}{3}(\\phi_{2})_{n-k-2} \\] \\[ (\\phi_{2})_n - Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}(I_{T_{2}})_{n} = Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3}{I_{T_{1}}}_{n-k} + \\frac{4}{3}(\\phi_{2})_{n-1} - \\frac{1}{3}(\\phi_{2})_{n-2} + (\\phi_{1})_{n-k} - \\frac{4}{3}(\\phi_{1})_{n-k-1} + \\frac{1}{3}(\\phi_{1})_{n-k-2} \\] This leads to the component stamp matrix: \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & - Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3} & 0 \\\\ 0 & 0 & 1 & -1 & 0 & - Z_{0}\\frac{2\\pi}{\\Phi_{0}}\\frac{2h}{3} \\end{bmatrix} \\begin{bmatrix} \\phi_{1}^{+} \\\\ \\phi_{1}^{-} \\\\ \\phi_{2}^{+} \\\\ \\phi_{2}^{-} \\\\ I_{T_{1}} \\\\ I_{T_{2}} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ 0 \\\\ 0 \\\\ V_{T_{1}} \\\\ V_{T_{2}} \\end{bmatrix} \\] With \\(V_{T_{1}}\\) and \\(V_{T_{2}}\\) the RHS of the expanded equations above.","title":"Transmission Line"},{"location":"comp_stamps/#mutual-inductance","text":"Mutual inductance allows simulation of coupling between inductors. This coupling adds an additional term to the inductor equation: \\[ v_{L_{1}}(t) = L1 \\frac{di_{1}(t)}{dt} + M\\frac{di_{2}(t)}{dt} \\] \\[ v_{L_{2}}(t) = L2 \\frac{di_{2}(t)}{dt} + M\\frac{di_{1}(t)}{dt} \\] with \\[ M = k\\sqrt{L_{1} L_{2}} \\] We expand these equations to: \\[ \\left(V_{L_{1}}\\right)_n - \\frac{3L_{1}}{2h}\\left(I_{L_{1}}\\right)_n - \\frac{3M}{2h}\\left(I_{L_{2}}\\right)_n = - \\frac{2L_{1}}{h}\\left(I_{L_{1}}\\right)_{n-1} + \\frac{L_{1}}{2h}\\left(I_{L_{1}}\\right)_{n-2} - \\frac{2M}{h}\\left(I_{L_{2}}\\right)_{n-1} + \\frac{M}{2h}\\left(I_{L_{2}}\\right)_{n-2} \\] \\[ \\left(V_{L_{2}}\\right)_n - \\frac{3L_{2}}{2h}\\left(I_{L_{2}}\\right)_n - \\frac{3M}{2h}\\left(I_{L_{1}}\\right)_n = - \\frac{2L_{2}}{h}\\left(I_{L_{2}}\\right)_{n-1} + \\frac{L_{2}}{2h}\\left(I_{L_{2}}\\right)_{n-2} - \\frac{2M}{h}\\left(I_{L_{1}}\\right)_{n-1} + \\frac{M}{2h}\\left(I_{L_{1}}\\right)_{n-2} \\] This leads to the component stamp matrix: \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & - \\frac{3L_{1}}{2h} & - \\frac{3M}{2h} \\\\ 0 & 0 & 1 & -1 & - \\frac{3M}{2h} & - \\frac{3L_{2}}{2h} \\\\ \\end{bmatrix} \\begin{bmatrix} V_{L_{1}}^{+} \\\\ V_{L_{1}}^{-} \\\\ V_{L_{2}}^{+} \\\\ V_{L_{2}}^{-} \\\\ I_{L_{1}} \\\\ I_{L_{2}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ - \\frac{2L_{1}}{h}\\left(I_{L_{1}}\\right)_{n-1} + \\frac{L_{1}}{2h}\\left(I_{L_{1}}\\right)_{n-2} - \\frac{2M}{h}\\left(I_{L_{2}}\\right)_{n-1} + \\frac{M}{2h}\\left(I_{L_{2}}\\right)_{n-2} \\\\ - \\frac{2L_{2}}{h}\\left(I_{L_{2}}\\right)_{n-1} + \\frac{L_{2}}{2h}\\left(I_{L_{2}}\\right)_{n-2} - \\frac{2M}{h}\\left(I_{L_{1}}\\right)_{n-1} + \\frac{M}{2h}\\left(I_{L_{1}}\\right)_{n-2} \\end{bmatrix} \\] The phase variant of this \\[ \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{L_{1}}}{dt} = L_{1}\\frac{di_{L_{1}}}{dt} + M\\frac{di_{L_{2}}}{dt} \\] \\[ \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{L_{2}}}{dt} =M\\frac{di_{L_{1}}}{dt} + L_{2}\\frac{di_{L_{2}}}{dt} \\] With integration on both sides \\[ \\frac{\\Phi_0}{2\\pi}\\phi_{L_{1}} = L_{1}I_{L_{1}} + MI_{L_{2}} \\] \\[ \\frac{\\Phi_0}{2\\pi}\\phi_{L_{2}} = MI_{L_{1}} + L_{2}I_{L_{2}} \\] This leads to a quite simplified component stamp matrix \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -\\frac{2\\pi}{\\Phi_0}L_{1} & -\\frac{2\\pi}{\\Phi_0}M \\\\ 0 & 0 & 1 & -1 & -\\frac{2\\pi}{\\Phi_0}M & -\\frac{2\\pi}{\\Phi_0}L_{2} \\\\ \\end{bmatrix} \\begin{bmatrix} \\phi_{L_{1}}^{+} \\\\ \\phi_{L_{1}}^{-} \\\\ \\phi_{L_{2}}^{+} \\\\ \\phi_{L_{2}}^{-} \\\\ I_{L_{1}} \\\\ I_{L_{2}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} \\]","title":"Mutual inductance"},{"location":"comp_stamps/#current-controlled-current-source","text":"Current controlled current source allows modulation of current in a particular branch through the current in a remote branch. \\[ I_{out} = \\beta I_{in} \\] \\[ V_{1} - V_{2} = 0 \\] \\[ \\beta = value \\] \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & \\frac{1}{\\beta} \\\\ 0 & 0 & 0 & 0 & -\\frac{1}{\\beta} \\\\ 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{out} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\]","title":"Current Controlled Current Source"},{"location":"comp_stamps/#current-controlled-voltage-source","text":"Current controlled voltage source allows the modulation of a voltage node through a remote current. \\[ V_{1} - V_{2} = 0 \\] \\[ V_{3} - V_{4} = \\mu I_{in} \\] \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 0 & -1 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & 0 & -1\\\\ 0 & 0 & 1 & -1 & -\\mu & 0\\\\ 1 & -1 & 0 & 0 & 0 & -\\mu \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{in}\\\\ I_{out}\\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\]","title":"Current Controlled Voltage Source"},{"location":"comp_stamps/#voltage-controlled-current-source","text":"Voltage controlled current source allows the modulation of a current in a branch through a remote voltage. \\[ \\alpha(V_{1} - V_{2}) = I_{out} \\] \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & -1\\\\ 1 & -1 & 0 & 0 & -\\frac{1}{\\alpha} \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{in} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\]","title":"Voltage Controlled Current Source"},{"location":"comp_stamps/#voltage-controlled-voltage-source","text":"Voltage controlled current source allows the modulation of a current in a branch through a remote voltage. \\[ A(V_{1} - V_{2}) = V_{3}-V_{4} \\] \\[ \\begin{bmatrix} 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & -1\\\\ G & -G & 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{out} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\] W. Haberkorn, H. Knauer and J. Richter, \"A theoretical study of the current-phase relation in Josephson contacts\" in physica status solidi (a) , vol. 47, no. 2, pp. K161-K164, 1978 \u21a9","title":"Voltage Controlled Voltage Source"},{"location":"ex_usage/","text":"Example Usage Basic JTL Example In this section we provide example usage for JoSIM. In the test subfolder of the repository the user will find multiple example files that can be used to test JoSIM with. In this example we will make use of the ex_jtl_basic.cir file. This is a basic Josephson transmission line (JTL) that transmits a single flux quantum pulse from input to output. * Example JTL Basic B01 3 7 jmod area=2.16 B02 6 8 jmod area=2.16 IB01 0 1 pwl(0 0 5p 280u) L01 4 3 2p L02 3 2 2.425p L03 2 6 2.425p L04 6 5 2.031p LP01 0 7 0.086p LP02 0 8 0.096p LPR01 2 1 0.278p LRB01 7 9 0.086p LRB02 8 10 0.086p RB01 9 3 5.23 RB02 10 6 5.23 ROUT 5 0 2 VIN 4 0 pwl(0 0 300p 0 302.5p 827.13u 305p 0 600p 0 602.5p 827.13u 605p 0) .model jmod jj(rtype=1, vg=2.8mV, cap=0.07pF, r0=160, rN=16, icrit=0.1mA) .tran 0.25p 1000p 0 0.25p .print DEVV VIN .print DEVI ROUT .print PHASE B01 .print PHASE B02 .end Only the device voltage (DEVV) of the input source (VIN), the device current (DEVI) of the output resistor (ROUT) and the phase of both junctions are requested to be output. The simulation executes for a total of 1000ps and produces a result every 0.25ps which results in 4000 points of data for each requested variable. We simulate this circuit (on a CentOS 7 machine) using the command: josim-cli -o ./ex_jtl_basic.csv ./ex_jtl_basic.cir -V 1 This simulation is almost instant, given the size of the problem and should take no longer than 10ms to complete. The results of this simulation are stored in the ex_jtl_basic.csv file of which an excerpt of the two events is shown below. time,\"V(VIN)\",\"I(ROUT)\",\"P(B01)\",\"P(B02)\" 0.000000e+00,0.000000e+00,0.000000e+00,-0.000000e+00,0.000000e+00 2.500000e-13,0.000000e+00,6.636509e-07,2.899951e-03,2.923977e-03 5.000000e-13,0.000000e+00,1.963239e-06,1.130820e-02,1.150191e-02 7.500000e-13,0.000000e+00,3.931372e-06,2.615879e-02,2.691635e-02 1.000000e-12,0.000000e+00,6.352259e-06,4.650288e-02,4.856039e-02 1.250000e-12,0.000000e+00,8.883856e-06,7.016312e-02,7.460258e-02 1.500000e-12,0.000000e+00,1.119620e-05,9.467237e-02,1.028169e-01 1.750000e-12,0.000000e+00,1.306925e-05,1.180767e-01,1.313045e-01 2.000000e-12,0.000000e+00,1.442942e-05,1.393699e-01,1.589077e-01 2.250000e-12,0.000000e+00,1.533178e-05,1.585212e-01,1.852864e-01 2.500000e-12,0.000000e+00,1.590988e-05,1.762000e-01,2.107379e-01 2.750000e-12,0.000000e+00,1.631792e-05,1.933666e-01,2.358942e-01 3.000000e-12,0.000000e+00,1.668458e-05,2.108929e-01,2.614215e-01 3.250000e-12,0.000000e+00,1.708811e-05,2.293210e-01,2.878081e-01 3.500000e-12,0.000000e+00,1.755325e-05,2.487930e-01,3.152722e-01 3.750000e-12,0.000000e+00,1.806395e-05,2.691245e-01,3.437779e-01 4.000000e-12,0.000000e+00,1.858336e-05,2.899579e-01,3.731206e-01 . . . . . . . . . . . . . . . 9.970000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.972500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.975000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.977500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.980000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.982500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.985000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.987500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.990000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.992500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.995000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.997500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 We then plot this result with the josim-plot script found in the scripts using the following command: josim-plot ./ex_jtl_basic.csv -t stacked This produces the following visualized result: Through the representation of the results visually, the user can see the two SFQ pulses at the input and through the output resistor, including the phases of the two junctions. The same process can be done for every example found in the test folder on the repository.","title":"Example Usage"},{"location":"ex_usage/#example-usage","text":"","title":"Example Usage"},{"location":"ex_usage/#basic-jtl-example","text":"In this section we provide example usage for JoSIM. In the test subfolder of the repository the user will find multiple example files that can be used to test JoSIM with. In this example we will make use of the ex_jtl_basic.cir file. This is a basic Josephson transmission line (JTL) that transmits a single flux quantum pulse from input to output. * Example JTL Basic B01 3 7 jmod area=2.16 B02 6 8 jmod area=2.16 IB01 0 1 pwl(0 0 5p 280u) L01 4 3 2p L02 3 2 2.425p L03 2 6 2.425p L04 6 5 2.031p LP01 0 7 0.086p LP02 0 8 0.096p LPR01 2 1 0.278p LRB01 7 9 0.086p LRB02 8 10 0.086p RB01 9 3 5.23 RB02 10 6 5.23 ROUT 5 0 2 VIN 4 0 pwl(0 0 300p 0 302.5p 827.13u 305p 0 600p 0 602.5p 827.13u 605p 0) .model jmod jj(rtype=1, vg=2.8mV, cap=0.07pF, r0=160, rN=16, icrit=0.1mA) .tran 0.25p 1000p 0 0.25p .print DEVV VIN .print DEVI ROUT .print PHASE B01 .print PHASE B02 .end Only the device voltage (DEVV) of the input source (VIN), the device current (DEVI) of the output resistor (ROUT) and the phase of both junctions are requested to be output. The simulation executes for a total of 1000ps and produces a result every 0.25ps which results in 4000 points of data for each requested variable. We simulate this circuit (on a CentOS 7 machine) using the command: josim-cli -o ./ex_jtl_basic.csv ./ex_jtl_basic.cir -V 1 This simulation is almost instant, given the size of the problem and should take no longer than 10ms to complete. The results of this simulation are stored in the ex_jtl_basic.csv file of which an excerpt of the two events is shown below. time,\"V(VIN)\",\"I(ROUT)\",\"P(B01)\",\"P(B02)\" 0.000000e+00,0.000000e+00,0.000000e+00,-0.000000e+00,0.000000e+00 2.500000e-13,0.000000e+00,6.636509e-07,2.899951e-03,2.923977e-03 5.000000e-13,0.000000e+00,1.963239e-06,1.130820e-02,1.150191e-02 7.500000e-13,0.000000e+00,3.931372e-06,2.615879e-02,2.691635e-02 1.000000e-12,0.000000e+00,6.352259e-06,4.650288e-02,4.856039e-02 1.250000e-12,0.000000e+00,8.883856e-06,7.016312e-02,7.460258e-02 1.500000e-12,0.000000e+00,1.119620e-05,9.467237e-02,1.028169e-01 1.750000e-12,0.000000e+00,1.306925e-05,1.180767e-01,1.313045e-01 2.000000e-12,0.000000e+00,1.442942e-05,1.393699e-01,1.589077e-01 2.250000e-12,0.000000e+00,1.533178e-05,1.585212e-01,1.852864e-01 2.500000e-12,0.000000e+00,1.590988e-05,1.762000e-01,2.107379e-01 2.750000e-12,0.000000e+00,1.631792e-05,1.933666e-01,2.358942e-01 3.000000e-12,0.000000e+00,1.668458e-05,2.108929e-01,2.614215e-01 3.250000e-12,0.000000e+00,1.708811e-05,2.293210e-01,2.878081e-01 3.500000e-12,0.000000e+00,1.755325e-05,2.487930e-01,3.152722e-01 3.750000e-12,0.000000e+00,1.806395e-05,2.691245e-01,3.437779e-01 4.000000e-12,0.000000e+00,1.858336e-05,2.899579e-01,3.731206e-01 . . . . . . . . . . . . . . . 9.970000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.972500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.975000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.977500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.980000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.982500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.985000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.987500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.990000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.992500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.995000e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 9.997500e-10,1.803219e-19,1.753829e-18,1.297098e+01,1.318194e+01 We then plot this result with the josim-plot script found in the scripts using the following command: josim-plot ./ex_jtl_basic.csv -t stacked This produces the following visualized result: Through the representation of the results visually, the user can see the two SFQ pulses at the input and through the output resistor, including the phases of the two junctions. The same process can be done for every example found in the test folder on the repository.","title":"Basic JTL Example"},{"location":"syntax/","text":"Syntax Guide In this section we will attempt to provide the user with a comprehensive guide of the available syntax within JoSIM JoSIM is CaSe InSeNsItIvE as each line is cast to uppercase upon read-in. Additionally, it is discouraged to add units to values since in some specific cases this creates confusion in interpretation of the values. An example of this is specifying Farad when assigning a capacitor its value since a value followed by F would be interpreted as Femto. This will lead to wanting a 5 Farad capacitor but receiving a 5 Femto Farad capacitor. Units are not interpreted by the simulator in any way since the component type implies the unit. Basic Syntax Each line follows similar syntax which uses the first non-blank space character as identifier. Each identifier tells JoSIM how to handle that specific line. Identifiers that start with a letter relate to physical components in the design, e.g. L, C, R. Lines of this kind almost always follows the same syntax in that it requires a label and two nodes. These nodes can be alphanumeric with the restriction of 0 and GND which indicate a grounded node. Additionally, the use of period ( . ) or vertical bars ( | ) in label or node names are prohibited as these are reserved characters within JoSIM. Lines that start with a period ( . ) indicate that the line relates in some way to simulation control. In this case the command that follows the period identifies the control, e.g. .tran, .print, .end. Comments are lines that start with an asterisk ( * ) or a hash ( # ). Comments are meant to be in a line of their own and will not work if placed at the end of a line. Lines that start with a plus sign ( + ) indicate that the line is a continuation of the previous line. Internally the two lines will be combined. In most cases the VALUE of a component can be replaced by a variable name or an expression. Variables can be defined using the .PARAM control. These will be discussed in detail further. Values in JoSIM can be modified with engineering notation or through suffixes. A list of the available suffixes is found below: Suffix Meaning Engineering Notation Equivalent F Femto 1E-15 P Pico 1E-12 N Nano 1E-9 U Micro 1E-6 M Milli 1E-3 K Kilo 1E3 MEG Mega 1E6 X Mega 1E6 G Giga 1E9 T Tera 1E12 Basic Components We will now run through all the available physical components and their limitations. Any parameter surrounded by square brackets are optional and nested square brackets mean that the encapsulated parameter relies on the existence of the previous. Resistor R Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 VALUE \u2003[temp=< TEMP >]\u2003[neb=< FREQ >] The value of a resistor is in Ohms. Temperature used for noise analysis in Kelvin. Units need to be excluded since K for Kelvin will be interpreted as Kilo by JoSIM, e.g. 4K will become 4000. Optional frequency parameter sets the noise effective bandwidth during noise analysis. Default is 1GHz. Inductor L Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 VALUE The value of an inductor is in Henry. Capacitor C Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 VALUE The value of a capacitor is in Farad. Josephson Junction (JJ) B Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 <PhaseNode> \u2003 MODEL \u2003[area=< AREA >]\u2003[ic=< IC >]\u2003[temp=< TEMP >]\u2003[neb=< FREQ >] A Josephson junction is a two terminal device but could also be defined with a third non-connected node to allow compatibility with WRspice. This node is not used in any way in JoSIM. The Josephson junction requires specification of a model name which can be defined anywhere in the program using the control .MODEL . When AREA or IC is not specified then an area=1 is used as default. The temp and neb commands have the same descriptions as for the resistor. Model This model control has the following syntax .MODEL \u2003 ModelName \u2003 ModelType ([ MODEL PARAMETERS ]) The only junction model currently supported by JoSIM is the RCSJ model and thus the only available ModelType is jj with the following tunable parameters: Parameter Range Default Description RTYPE 0, 1 1 Linearization model used VG or VGAP - \\(\\infty\\) , \\(\\infty\\) 2.8E-3 Junction gap voltage IC or ICRIT - \\(\\infty\\) , \\(\\infty\\) 1E-3 Junction critical current RN 0, \\(\\infty\\) 5 Junction normal resistance R0 0, \\(\\infty\\) 30 Junction subgap resistance C or CAP 0, \\(\\infty\\) 2.5E-12 Junction capacitance T 0, \\(\\infty\\) 4.2 Boiling point of liquid coolant TC 0, \\(\\infty\\) 9.1 Critical temperature of superconducting material DELV 0, \\(\\infty\\) 0.1E-3 Transitional voltage from subgap to normal D 0.0, 1 0.0 Point of contact transparency affecting current phase relationship ICFCT or ICFACT 0, 1 \\(\\frac{\\pi}{4}\\) Ratio of critical current to quasiparticle step height PHI 0, \\(2\\pi\\) 0 Allows phi-junction capability such as the \\(\\pi\\) -junction. The .model line is unique to the subcircuit it falls under and can thus allow different models with the same name under separate subcircuits. If the model is not found under the subcircuit it will be searched for globally and if not found default values (default model) will be used instead. The AREA and IC parameters act as modifiers to the model parameters. AREA is a critical current multiplier, where if IC is specified it replaces the AREA value by \\(AREA=\\frac{IC_{jj}}{IC_{model}}\\) . By setting the PHI parameter of the model, the phase value is persistantly subtracted from the phase ( \\(\\phi\\) ) in the \\(\\sin(\\phi)\\) part of the JJ current. This allows elements such as the \\(\\pi\\) -junction to be modeled. Transmission Line T Label\u2003 \\(N^{+}_{1}\\) \u2003 \\(N^{-}_{1}\\) \u2003 \\(N^{+}_{2}\\) \u2003 \\(N^{-}_{2}\\) \u2003 TD=VALUE \u2003 Z0=VALUE TD is the time delay in seconds. Z0 is the impedance in Ohms. Mutual Inductance K Label\u2003 \\(L_{1}\\) \u2003 \\(L_{2}\\) \u2003 VALUE The value is the coupling factor k . Sources Independent Sources Voltage Source V Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 SOURCETYPE Current Source I Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 SOURCETYPE Phase Source P Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 SOURCETYPE Dependent Sources Current controlled current source F Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 \\(N^{+}\\) Control\u2003 \\(N^{-}\\) Control\u2003 CURRENT GAIN Current controlled voltage source H Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 \\(N^{+}\\) Control\u2003 \\(N^{-}\\) Control\u2003 TRANSRESISTANCE IN OHMS Voltage controlled current source G Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 \\(N^{+}\\) Control\u2003 \\(N^{-}\\) Control\u2003 TRANSCONDUCTANCE IN MHOS Voltage controlled voltage source E Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 \\(N^{+}\\) Control\u2003 \\(N^{-}\\) Control\u2003 VOLTAGE GAIN Source Types Piece Wise Linear (PWL) pwl(0 \u2003 0 \u2003 \\(T_{1}\\) \u2003 \\(A_{1}\\) \u2003...\u2003 \\(T_{n}\\) \u2003 \\(A_{n}\\) ) This source linearly interpolates amplitude values for every time point in the simulation between the specified amplitudes. The initial two values are required to be zero at the start of the simulation. Pulse pulse( \\(A_{1}\\) \u2003 \\(A_{2}\\) \u2003[ \\(T_{D}\\) \u2003[ \\(T_{R}\\) \u2003[ \\(T_{F}\\) \u2003[ PW \u2003[ PER ]]]]] ) This source generates a pulse between two amplitudes ( \\(A_{1}\\) and \\(A_{2}\\) ), starts after \\(T_{D}\\) and has a rise and fall time ( \\(T_{R}\\) & \\(T_{F}\\) ), which default to the transient simulation step size. PW and PER refer to the pulse width and the period respectively. These values default to the transient simulation stop time when not specified. This source allows the continuous generation of a pulse at a set frequency. Sinusoidal sin( \\(A_{O}\\) \u2003 \\(A\\) \u2003[ \\(f\\) \u2003[ \\(T_{D}\\) \u2003[ \\(\\theta\\) ]]] ) A source that generates a sinusoidal signal with \\(A_{O}\\) offset and \\(A\\) amplitude at a frequency of \\(f\\) which defaults to \\(\\frac{1}{T_{STOP}}\\) . \\(T_{D}\\) sets the stop time and \\(\\theta\\) modulates the signal amplitude. The function generates a data point for each step in the transient simulation based on the following equation: \\(f(t)=A_{O}+A\\sin(2\\pi f(t-T_{D}))e^{-\\theta(t-T_{D})}\\) Custom Waveform cus( wavefile \u2003 \\(T_{S}\\) \u2003 SF \u2003 IM \u2003[ \\(T_{D}\\) \u2003 PER] ) This source allows the generates a function based on the points inside the plain text wave file. This file should contain a single line of space separated numbers. E.g 0 2 3 6 2 1 0 Each number in this line represents an amplitude separated by time step \\(T_{S}\\) and scaled using scale factor SF . The values between the points are interpolated using either no interpolation (0), linear (1) or cubic (2). The function can become periodic if PER is set to 1, whereby the pattern is repeated for the entire simulation. The waveform only starts of \\(T_{D}\\) . DC dc \u2003 \\(A\\) A DC source that is always at \\(A\\) at any given time during the simulation. Noise noise( \\(A\\) \u2003 \\(T_{D}\\) \u2003 \\(T_{STEP}\\) ) This source produces a noise value for the time step provided that it is after \\(T_{D}\\) . The \\(T_{STEP}\\) is the inverse of the noise effective bandwidth set globally using .neb or locally for a resistor using neb= . The noise value returned is calculated using the following equation: \\(f(t) = A\\frac{GRAND()}{\\sqrt{2T_{STEP}}}\\) \\(GRAND()\\) is a Gaussian random number generating function. Exponential exp( \\(A_{1}\\) \u2003 \\(A_{2}\\) \u2003 \\(T_{D1}\\) \u2003 \\(\\tau_{1}\\) \u2003 \\(T_{D2}\\) \u2003 \\(\\tau_{2}\\) ) Parameter Default \\(T_{D1}\\) 0.0 \\(T_{D2}\\) \\(T_{STEP}\\) \\(\\tau_{1}\\) \\(T_{D1}+T_{STEP}\\) \\(\\tau_{2}\\) \\(T_{STEP}\\) Returns different values for the 3 different time segments. For \\(t < T_{D1}\\) : \\(f(t)=A_{1}\\) For \\(T_{D1}\\le t < T_{D2}\\) : \\(f(t) = A_{1}+(A_{2}-A_{1})(1-e^{\\frac{t - T_{D1}}{\\tau_{1}}})\\) For \\(T_{D2} \\le t\\) : \\(f(t) = A_{1}+(A_{2}-A_{1})(1-e^{\\frac{t - T_{D1}}{\\tau_{1}}})+(A_{1}-A_{2})(1-e^{\\frac{t - T_{D2}}{\\tau_{2}}})\\) Control Commands The simulation engine requires control commands to know what to do with the components it has just been provided with. The most important of these control commands is the transient simulation command as no simulation can be performed without it. Transient Analysis .tran \u2003 \\(T_{STEP}\\) \u2003 \\(T_{STOP}\\) \u2003[ \\(P_{START}\\) \u2003[ \\(P_{STEP}\\) ]]\u2003DST This generates a simulation that runs from 0 until \\(T_{STOP}\\) . The amount simulation steps that will be performed is \\(n=\\frac{T_{STOP}}{T_{STEP}}\\) . \\(P_{START}\\) indicates at what point output will start printing. \\(P_{STEP}\\) sets the size of the print steps. This has to be larger or equal to \\(T_{STEP}\\) . DST disables the start-up time. The start-up time is a period calculated internally by the simulator in which components settle. This is equivalent to the few picoseconds from when a circuit initially receives power (power switch flipped). Subcircuits Subcircuits allow subdivision and reuse of smaller circuits within a larger design. When wrapped in a subcircuit control devices are allowed to have the same label names as specified elsewhere in the netlist as the subcircuit completely isolates them. Subcircuits have the following wrapping control syntax .subckt \u2003 SubcktName \u2003 IO Nodes ... .ends The SubcktName specifies the name of the subcircuit and IO Nodes specify the which nodes within the subcircuit connects to outside. A subcircuit can be used in the main netlist or another subcircuit (nesting) using the following syntax X Label\u2003 SubcktName \u2003 IO Nodes \u2003(JSIM mode) X Label\u2003 IO Nodes \u2003 SubcktName \u2003(WRspice (normal SPICE) mode) Additionally, keywords in the form of LABEL=VALUE can be appended to the end of the subcircuit declaration line which when instantiated will replace the value of the LABEL component within the subcircuit with the associated VALUE . This allows for unique subcircuit instantiations which would prove useful in testing various parameters without altering the original subcircuit or having multiple instances of the same subcircuit definition. This could open the door for potential future margin and optimization software. Noise As mentioned in the technical discussion, noise can be automatically inserted as current sources in parallel to each resistor. This thermal noise temperature and bandwidth can be specified globally using the following commands: .temp \u2003 Temperature in Kelvin .neb \u2003 Bandwidth in Hertz Spread JoSIM allows each value of inductors, resistors, capacitors and JJ (area/Ic) to be spread uniformly within a specified percentage range from the nominal value. Each time the value is used (in matrix creation), a new random value from the uniform distribution is chosen. This allows for process variation to be simulated. To set the spread globally, the following control needs to be set: .spread \u2003 Normalized percentage \u2003 [L=Inductor spread] \u2003 [B=JJ spread] \u2003 [C=Capacitor spread] \u2003 [R=Resistor spread] Each individual component can also be spread by adding the spread= named parameter to the component declaration line. The order of precedence is taken as local, specific global and then global. This means that if a global spread exists but a global inductor specific spread also exists and the inductor being added has a local spread then the local spread will take precedence. An example: If an inductor has a value of 2pH , this is its nominal value. If a local spread of 0.2 is specified this means a random value can be chosen anywhere between 1.6pH and 2.4pH . If global inductor specific spread is specified as 0.3 and the local spread is not defined, the value can be anything within the range 1.4pH - 2.6pH . Similarly if the global spread is defined as 0.5 then the value each time the simulation is run can be anywhere between 1pH and 3pH . IV Curve JoSIM allows the user to output an IV curve for a specified JJ model within the netlist using the following command: .iv \u2003 modelname \u2003 max_current \u2003 filepath This command outputs a comma seperated value (CSV) at the filepath specified which contains the IV curve data for the modelname from negative max_current to positive max_current . Subcircuit models can be output using the . (period) or | (vertical bar) as separator between the modelname and the subcircuit NAME. Output A simulation is meaningless unless the results are post processed. In order to know which of these results are relevant for storage the simulator needs output control commands. These output commands can be of either .print \u2003 .plot \u2003 .save Any of these commands can be followed by either of the following commands PrintType \u2003 Device or Node PType(Device or Node) \\(_0\\) \u2003 ... \u2003 PType(Device or Node) \\(_n\\) Where PrintType can be either device voltage ( DEVV ), device current ( DEVI ), device phase ( PHASE ), node voltage ( NODEV ) or node phase ( NODEP ). When specifying a device type store only a single device can be specified, but when a node type store is specified 2 nodes can be specified to store the difference between them. PType is shorthand for the above and can have multiple per line requests. PType can be either of V , I (or C ) or P followed by the device or node in brackets. If more than one device or node is specified by comma seperation (maximum 2) the difference between the two devices or nodes is stored. An additional save type exists that has the following syntax @ Device [ PType ] This stores the PType of the device specified. Subcircuit parameters can be output using the . (period) or | (vertical bar) as separator between the device label and the subcircuit label name. i.e. .print v(14.X01) p(B01.X02) This method follows the path from inside to out when nested subcircuits are used. Subcircuits as mentioned before can also be nested almost indefinitely as they are expanded upon simulation. If the label is not immediately apparent and required for output, the simulation can be run using the -V 3 cli option to show the expanded main design, allowing the exact label name to be identified. File Multi-file output can be achieved by separating output commands with the following command: .file \u2003 filepath This indicates that every output request that follows this command needs to be stored in the file specified by filepath . I.e. .file output1.csv .print p(B1) p(B2) p(B3) .file output2.dat .plot i(L01) i(L02) i(L03) .file output3 .save v(1) v(2) v(3) This will create 3 output files. The first will be a CSV file containing only the phase outputs. The second file will be a space separated file containing only the currents. Lastly, the third file will be in a SPICE RAW format and contain only the voltages. The use of this command does not affect the command line option request to output a file. The command line output option, if requested, will output an additional file which contains all of the output requests (phase, current and voltage). Parameters The final control command that is of importance in JoSIM is the parameters command with the following syntax .param \u2003 VarName = Expression VarName is the variable name that can be used anywhere else in the circuit and Expression is a mathematical expression that is evaluated using an implementation of Dijkstra's shunting yard algorithm, whereby the expression is converted into reverse polish notation (RPN) and evaluated. Additionally, expressions can also contain other variables and parameters will be continuously evaluated until all variables are reduced to values. If variables are not defined the program will halt and produce an error. Expression parsing is exclusive to the .param control. This means that if expressions are loosely provided as values to components or as parameters to plot or model controls, JoSIM will error in std::invalid_argument: stod: no conversion as it tries to convert a string into a double. Please be mindful when using expressions and restrict them to .param controls. Control Block Any of the above controls can be wrapped inside a control block with the following syntax .control ... .endc Wherein all controls can be specified by omitting the usual prepending . (period) to the command. This block, though seemingly useless at present, will be used for more advanced functionality in the future. Include JoSIM allows the use of a .include control card that uses the following syntax .include relative_path_to_file This command reads in the contents of the relevant file pointed to by the relevant path upon parsing of the netlist essentially extending the netlist by the linked file. This is incredibly handy when large subcircuits are involved and reuse of subcircuits across multiple files is required. This can also be used to house all the models used in simulation allowing a central point of alteration if the model is changed. Standard Input JoSIM now allows input from standard input allowing a line-by-line read in of a netlist until the .end card is found or alternatively the EOF character is returned. Constants JoSIM has a set of built in constants that when used expand to the corresponding values. Below is a list of these constants and their values. The constants names are case insensitive: Constant Symbol Value PI \\(\\pi\\) 3.141592653589793238463 PHI_ZERO \\(\\Phi_{0}\\) 2.067833831170082E-15 BOLTZMANN \\(k_{B}\\) 1.38064852E-23 EV \\(e\\) 1.6021766208E-19 HBAR \\(\\bar{h}\\) 1.0545718001391127E-34 C \\(c\\) 299792458 MU0 \\(\\mu_{0}\\) 12.566370614E-7 EPS0 \\(\\epsilon_{0}\\) 8.854187817E-12 SIGMA \\(\\sigma\\) (short for \\(\\frac{\\Phi_{0}}{2\\pi}\\) ) 3.291059757E-16","title":"Syntax Guide"},{"location":"syntax/#syntax-guide","text":"In this section we will attempt to provide the user with a comprehensive guide of the available syntax within JoSIM JoSIM is CaSe InSeNsItIvE as each line is cast to uppercase upon read-in. Additionally, it is discouraged to add units to values since in some specific cases this creates confusion in interpretation of the values. An example of this is specifying Farad when assigning a capacitor its value since a value followed by F would be interpreted as Femto. This will lead to wanting a 5 Farad capacitor but receiving a 5 Femto Farad capacitor. Units are not interpreted by the simulator in any way since the component type implies the unit.","title":"Syntax Guide"},{"location":"syntax/#basic-syntax","text":"Each line follows similar syntax which uses the first non-blank space character as identifier. Each identifier tells JoSIM how to handle that specific line. Identifiers that start with a letter relate to physical components in the design, e.g. L, C, R. Lines of this kind almost always follows the same syntax in that it requires a label and two nodes. These nodes can be alphanumeric with the restriction of 0 and GND which indicate a grounded node. Additionally, the use of period ( . ) or vertical bars ( | ) in label or node names are prohibited as these are reserved characters within JoSIM. Lines that start with a period ( . ) indicate that the line relates in some way to simulation control. In this case the command that follows the period identifies the control, e.g. .tran, .print, .end. Comments are lines that start with an asterisk ( * ) or a hash ( # ). Comments are meant to be in a line of their own and will not work if placed at the end of a line. Lines that start with a plus sign ( + ) indicate that the line is a continuation of the previous line. Internally the two lines will be combined. In most cases the VALUE of a component can be replaced by a variable name or an expression. Variables can be defined using the .PARAM control. These will be discussed in detail further. Values in JoSIM can be modified with engineering notation or through suffixes. A list of the available suffixes is found below: Suffix Meaning Engineering Notation Equivalent F Femto 1E-15 P Pico 1E-12 N Nano 1E-9 U Micro 1E-6 M Milli 1E-3 K Kilo 1E3 MEG Mega 1E6 X Mega 1E6 G Giga 1E9 T Tera 1E12","title":"Basic Syntax"},{"location":"syntax/#basic-components","text":"We will now run through all the available physical components and their limitations. Any parameter surrounded by square brackets are optional and nested square brackets mean that the encapsulated parameter relies on the existence of the previous.","title":"Basic Components"},{"location":"syntax/#resistor","text":"R Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 VALUE \u2003[temp=< TEMP >]\u2003[neb=< FREQ >] The value of a resistor is in Ohms. Temperature used for noise analysis in Kelvin. Units need to be excluded since K for Kelvin will be interpreted as Kilo by JoSIM, e.g. 4K will become 4000. Optional frequency parameter sets the noise effective bandwidth during noise analysis. Default is 1GHz.","title":"Resistor"},{"location":"syntax/#inductor","text":"L Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 VALUE The value of an inductor is in Henry.","title":"Inductor"},{"location":"syntax/#capacitor","text":"C Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 VALUE The value of a capacitor is in Farad.","title":"Capacitor"},{"location":"syntax/#josephson-junction-jj","text":"B Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 <PhaseNode> \u2003 MODEL \u2003[area=< AREA >]\u2003[ic=< IC >]\u2003[temp=< TEMP >]\u2003[neb=< FREQ >] A Josephson junction is a two terminal device but could also be defined with a third non-connected node to allow compatibility with WRspice. This node is not used in any way in JoSIM. The Josephson junction requires specification of a model name which can be defined anywhere in the program using the control .MODEL . When AREA or IC is not specified then an area=1 is used as default. The temp and neb commands have the same descriptions as for the resistor.","title":"Josephson Junction (JJ)"},{"location":"syntax/#model","text":"This model control has the following syntax .MODEL \u2003 ModelName \u2003 ModelType ([ MODEL PARAMETERS ]) The only junction model currently supported by JoSIM is the RCSJ model and thus the only available ModelType is jj with the following tunable parameters: Parameter Range Default Description RTYPE 0, 1 1 Linearization model used VG or VGAP - \\(\\infty\\) , \\(\\infty\\) 2.8E-3 Junction gap voltage IC or ICRIT - \\(\\infty\\) , \\(\\infty\\) 1E-3 Junction critical current RN 0, \\(\\infty\\) 5 Junction normal resistance R0 0, \\(\\infty\\) 30 Junction subgap resistance C or CAP 0, \\(\\infty\\) 2.5E-12 Junction capacitance T 0, \\(\\infty\\) 4.2 Boiling point of liquid coolant TC 0, \\(\\infty\\) 9.1 Critical temperature of superconducting material DELV 0, \\(\\infty\\) 0.1E-3 Transitional voltage from subgap to normal D 0.0, 1 0.0 Point of contact transparency affecting current phase relationship ICFCT or ICFACT 0, 1 \\(\\frac{\\pi}{4}\\) Ratio of critical current to quasiparticle step height PHI 0, \\(2\\pi\\) 0 Allows phi-junction capability such as the \\(\\pi\\) -junction. The .model line is unique to the subcircuit it falls under and can thus allow different models with the same name under separate subcircuits. If the model is not found under the subcircuit it will be searched for globally and if not found default values (default model) will be used instead. The AREA and IC parameters act as modifiers to the model parameters. AREA is a critical current multiplier, where if IC is specified it replaces the AREA value by \\(AREA=\\frac{IC_{jj}}{IC_{model}}\\) . By setting the PHI parameter of the model, the phase value is persistantly subtracted from the phase ( \\(\\phi\\) ) in the \\(\\sin(\\phi)\\) part of the JJ current. This allows elements such as the \\(\\pi\\) -junction to be modeled.","title":"Model"},{"location":"syntax/#transmission-line","text":"T Label\u2003 \\(N^{+}_{1}\\) \u2003 \\(N^{-}_{1}\\) \u2003 \\(N^{+}_{2}\\) \u2003 \\(N^{-}_{2}\\) \u2003 TD=VALUE \u2003 Z0=VALUE TD is the time delay in seconds. Z0 is the impedance in Ohms.","title":"Transmission Line"},{"location":"syntax/#mutual-inductance","text":"K Label\u2003 \\(L_{1}\\) \u2003 \\(L_{2}\\) \u2003 VALUE The value is the coupling factor k .","title":"Mutual Inductance"},{"location":"syntax/#sources","text":"","title":"Sources"},{"location":"syntax/#independent-sources","text":"","title":"Independent Sources"},{"location":"syntax/#voltage-source","text":"V Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 SOURCETYPE","title":"Voltage Source"},{"location":"syntax/#current-source","text":"I Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 SOURCETYPE","title":"Current Source"},{"location":"syntax/#phase-source","text":"P Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 SOURCETYPE","title":"Phase Source"},{"location":"syntax/#dependent-sources","text":"","title":"Dependent Sources"},{"location":"syntax/#current-controlled-current-source","text":"F Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 \\(N^{+}\\) Control\u2003 \\(N^{-}\\) Control\u2003 CURRENT GAIN","title":"Current controlled current source"},{"location":"syntax/#current-controlled-voltage-source","text":"H Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 \\(N^{+}\\) Control\u2003 \\(N^{-}\\) Control\u2003 TRANSRESISTANCE IN OHMS","title":"Current controlled voltage source"},{"location":"syntax/#voltage-controlled-current-source","text":"G Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 \\(N^{+}\\) Control\u2003 \\(N^{-}\\) Control\u2003 TRANSCONDUCTANCE IN MHOS","title":"Voltage controlled current source"},{"location":"syntax/#voltage-controlled-voltage-source","text":"E Label\u2003 \\(N^{+}\\) \u2003 \\(N^{-}\\) \u2003 \\(N^{+}\\) Control\u2003 \\(N^{-}\\) Control\u2003 VOLTAGE GAIN","title":"Voltage controlled voltage source"},{"location":"syntax/#source-types","text":"","title":"Source Types"},{"location":"syntax/#piece-wise-linear-pwl","text":"pwl(0 \u2003 0 \u2003 \\(T_{1}\\) \u2003 \\(A_{1}\\) \u2003...\u2003 \\(T_{n}\\) \u2003 \\(A_{n}\\) ) This source linearly interpolates amplitude values for every time point in the simulation between the specified amplitudes. The initial two values are required to be zero at the start of the simulation.","title":"Piece Wise Linear (PWL)"},{"location":"syntax/#pulse","text":"pulse( \\(A_{1}\\) \u2003 \\(A_{2}\\) \u2003[ \\(T_{D}\\) \u2003[ \\(T_{R}\\) \u2003[ \\(T_{F}\\) \u2003[ PW \u2003[ PER ]]]]] ) This source generates a pulse between two amplitudes ( \\(A_{1}\\) and \\(A_{2}\\) ), starts after \\(T_{D}\\) and has a rise and fall time ( \\(T_{R}\\) & \\(T_{F}\\) ), which default to the transient simulation step size. PW and PER refer to the pulse width and the period respectively. These values default to the transient simulation stop time when not specified. This source allows the continuous generation of a pulse at a set frequency.","title":"Pulse"},{"location":"syntax/#sinusoidal","text":"sin( \\(A_{O}\\) \u2003 \\(A\\) \u2003[ \\(f\\) \u2003[ \\(T_{D}\\) \u2003[ \\(\\theta\\) ]]] ) A source that generates a sinusoidal signal with \\(A_{O}\\) offset and \\(A\\) amplitude at a frequency of \\(f\\) which defaults to \\(\\frac{1}{T_{STOP}}\\) . \\(T_{D}\\) sets the stop time and \\(\\theta\\) modulates the signal amplitude. The function generates a data point for each step in the transient simulation based on the following equation: \\(f(t)=A_{O}+A\\sin(2\\pi f(t-T_{D}))e^{-\\theta(t-T_{D})}\\)","title":"Sinusoidal"},{"location":"syntax/#custom-waveform","text":"cus( wavefile \u2003 \\(T_{S}\\) \u2003 SF \u2003 IM \u2003[ \\(T_{D}\\) \u2003 PER] ) This source allows the generates a function based on the points inside the plain text wave file. This file should contain a single line of space separated numbers. E.g 0 2 3 6 2 1 0 Each number in this line represents an amplitude separated by time step \\(T_{S}\\) and scaled using scale factor SF . The values between the points are interpolated using either no interpolation (0), linear (1) or cubic (2). The function can become periodic if PER is set to 1, whereby the pattern is repeated for the entire simulation. The waveform only starts of \\(T_{D}\\) .","title":"Custom Waveform"},{"location":"syntax/#dc","text":"dc \u2003 \\(A\\) A DC source that is always at \\(A\\) at any given time during the simulation.","title":"DC"},{"location":"syntax/#noise","text":"noise( \\(A\\) \u2003 \\(T_{D}\\) \u2003 \\(T_{STEP}\\) ) This source produces a noise value for the time step provided that it is after \\(T_{D}\\) . The \\(T_{STEP}\\) is the inverse of the noise effective bandwidth set globally using .neb or locally for a resistor using neb= . The noise value returned is calculated using the following equation: \\(f(t) = A\\frac{GRAND()}{\\sqrt{2T_{STEP}}}\\) \\(GRAND()\\) is a Gaussian random number generating function.","title":"Noise"},{"location":"syntax/#exponential","text":"exp( \\(A_{1}\\) \u2003 \\(A_{2}\\) \u2003 \\(T_{D1}\\) \u2003 \\(\\tau_{1}\\) \u2003 \\(T_{D2}\\) \u2003 \\(\\tau_{2}\\) ) Parameter Default \\(T_{D1}\\) 0.0 \\(T_{D2}\\) \\(T_{STEP}\\) \\(\\tau_{1}\\) \\(T_{D1}+T_{STEP}\\) \\(\\tau_{2}\\) \\(T_{STEP}\\) Returns different values for the 3 different time segments. For \\(t < T_{D1}\\) : \\(f(t)=A_{1}\\) For \\(T_{D1}\\le t < T_{D2}\\) : \\(f(t) = A_{1}+(A_{2}-A_{1})(1-e^{\\frac{t - T_{D1}}{\\tau_{1}}})\\) For \\(T_{D2} \\le t\\) : \\(f(t) = A_{1}+(A_{2}-A_{1})(1-e^{\\frac{t - T_{D1}}{\\tau_{1}}})+(A_{1}-A_{2})(1-e^{\\frac{t - T_{D2}}{\\tau_{2}}})\\)","title":"Exponential"},{"location":"syntax/#control-commands","text":"The simulation engine requires control commands to know what to do with the components it has just been provided with. The most important of these control commands is the transient simulation command as no simulation can be performed without it.","title":"Control Commands"},{"location":"syntax/#transient-analysis","text":".tran \u2003 \\(T_{STEP}\\) \u2003 \\(T_{STOP}\\) \u2003[ \\(P_{START}\\) \u2003[ \\(P_{STEP}\\) ]]\u2003DST This generates a simulation that runs from 0 until \\(T_{STOP}\\) . The amount simulation steps that will be performed is \\(n=\\frac{T_{STOP}}{T_{STEP}}\\) . \\(P_{START}\\) indicates at what point output will start printing. \\(P_{STEP}\\) sets the size of the print steps. This has to be larger or equal to \\(T_{STEP}\\) . DST disables the start-up time. The start-up time is a period calculated internally by the simulator in which components settle. This is equivalent to the few picoseconds from when a circuit initially receives power (power switch flipped).","title":"Transient Analysis"},{"location":"syntax/#subcircuits","text":"Subcircuits allow subdivision and reuse of smaller circuits within a larger design. When wrapped in a subcircuit control devices are allowed to have the same label names as specified elsewhere in the netlist as the subcircuit completely isolates them. Subcircuits have the following wrapping control syntax .subckt \u2003 SubcktName \u2003 IO Nodes ... .ends The SubcktName specifies the name of the subcircuit and IO Nodes specify the which nodes within the subcircuit connects to outside. A subcircuit can be used in the main netlist or another subcircuit (nesting) using the following syntax X Label\u2003 SubcktName \u2003 IO Nodes \u2003(JSIM mode) X Label\u2003 IO Nodes \u2003 SubcktName \u2003(WRspice (normal SPICE) mode) Additionally, keywords in the form of LABEL=VALUE can be appended to the end of the subcircuit declaration line which when instantiated will replace the value of the LABEL component within the subcircuit with the associated VALUE . This allows for unique subcircuit instantiations which would prove useful in testing various parameters without altering the original subcircuit or having multiple instances of the same subcircuit definition. This could open the door for potential future margin and optimization software.","title":"Subcircuits"},{"location":"syntax/#noise_1","text":"As mentioned in the technical discussion, noise can be automatically inserted as current sources in parallel to each resistor. This thermal noise temperature and bandwidth can be specified globally using the following commands: .temp \u2003 Temperature in Kelvin .neb \u2003 Bandwidth in Hertz","title":"Noise"},{"location":"syntax/#spread","text":"JoSIM allows each value of inductors, resistors, capacitors and JJ (area/Ic) to be spread uniformly within a specified percentage range from the nominal value. Each time the value is used (in matrix creation), a new random value from the uniform distribution is chosen. This allows for process variation to be simulated. To set the spread globally, the following control needs to be set: .spread \u2003 Normalized percentage \u2003 [L=Inductor spread] \u2003 [B=JJ spread] \u2003 [C=Capacitor spread] \u2003 [R=Resistor spread] Each individual component can also be spread by adding the spread= named parameter to the component declaration line. The order of precedence is taken as local, specific global and then global. This means that if a global spread exists but a global inductor specific spread also exists and the inductor being added has a local spread then the local spread will take precedence. An example: If an inductor has a value of 2pH , this is its nominal value. If a local spread of 0.2 is specified this means a random value can be chosen anywhere between 1.6pH and 2.4pH . If global inductor specific spread is specified as 0.3 and the local spread is not defined, the value can be anything within the range 1.4pH - 2.6pH . Similarly if the global spread is defined as 0.5 then the value each time the simulation is run can be anywhere between 1pH and 3pH .","title":"Spread"},{"location":"syntax/#iv-curve","text":"JoSIM allows the user to output an IV curve for a specified JJ model within the netlist using the following command: .iv \u2003 modelname \u2003 max_current \u2003 filepath This command outputs a comma seperated value (CSV) at the filepath specified which contains the IV curve data for the modelname from negative max_current to positive max_current . Subcircuit models can be output using the . (period) or | (vertical bar) as separator between the modelname and the subcircuit NAME.","title":"IV Curve"},{"location":"syntax/#output","text":"A simulation is meaningless unless the results are post processed. In order to know which of these results are relevant for storage the simulator needs output control commands. These output commands can be of either .print \u2003 .plot \u2003 .save Any of these commands can be followed by either of the following commands PrintType \u2003 Device or Node PType(Device or Node) \\(_0\\) \u2003 ... \u2003 PType(Device or Node) \\(_n\\) Where PrintType can be either device voltage ( DEVV ), device current ( DEVI ), device phase ( PHASE ), node voltage ( NODEV ) or node phase ( NODEP ). When specifying a device type store only a single device can be specified, but when a node type store is specified 2 nodes can be specified to store the difference between them. PType is shorthand for the above and can have multiple per line requests. PType can be either of V , I (or C ) or P followed by the device or node in brackets. If more than one device or node is specified by comma seperation (maximum 2) the difference between the two devices or nodes is stored. An additional save type exists that has the following syntax @ Device [ PType ] This stores the PType of the device specified. Subcircuit parameters can be output using the . (period) or | (vertical bar) as separator between the device label and the subcircuit label name. i.e. .print v(14.X01) p(B01.X02) This method follows the path from inside to out when nested subcircuits are used. Subcircuits as mentioned before can also be nested almost indefinitely as they are expanded upon simulation. If the label is not immediately apparent and required for output, the simulation can be run using the -V 3 cli option to show the expanded main design, allowing the exact label name to be identified.","title":"Output"},{"location":"syntax/#file","text":"Multi-file output can be achieved by separating output commands with the following command: .file \u2003 filepath This indicates that every output request that follows this command needs to be stored in the file specified by filepath . I.e. .file output1.csv .print p(B1) p(B2) p(B3) .file output2.dat .plot i(L01) i(L02) i(L03) .file output3 .save v(1) v(2) v(3) This will create 3 output files. The first will be a CSV file containing only the phase outputs. The second file will be a space separated file containing only the currents. Lastly, the third file will be in a SPICE RAW format and contain only the voltages. The use of this command does not affect the command line option request to output a file. The command line output option, if requested, will output an additional file which contains all of the output requests (phase, current and voltage).","title":"File"},{"location":"syntax/#parameters","text":"The final control command that is of importance in JoSIM is the parameters command with the following syntax .param \u2003 VarName = Expression VarName is the variable name that can be used anywhere else in the circuit and Expression is a mathematical expression that is evaluated using an implementation of Dijkstra's shunting yard algorithm, whereby the expression is converted into reverse polish notation (RPN) and evaluated. Additionally, expressions can also contain other variables and parameters will be continuously evaluated until all variables are reduced to values. If variables are not defined the program will halt and produce an error. Expression parsing is exclusive to the .param control. This means that if expressions are loosely provided as values to components or as parameters to plot or model controls, JoSIM will error in std::invalid_argument: stod: no conversion as it tries to convert a string into a double. Please be mindful when using expressions and restrict them to .param controls.","title":"Parameters"},{"location":"syntax/#control-block","text":"Any of the above controls can be wrapped inside a control block with the following syntax .control ... .endc Wherein all controls can be specified by omitting the usual prepending . (period) to the command. This block, though seemingly useless at present, will be used for more advanced functionality in the future.","title":"Control Block"},{"location":"syntax/#include","text":"JoSIM allows the use of a .include control card that uses the following syntax .include relative_path_to_file This command reads in the contents of the relevant file pointed to by the relevant path upon parsing of the netlist essentially extending the netlist by the linked file. This is incredibly handy when large subcircuits are involved and reuse of subcircuits across multiple files is required. This can also be used to house all the models used in simulation allowing a central point of alteration if the model is changed.","title":"Include"},{"location":"syntax/#standard-input","text":"JoSIM now allows input from standard input allowing a line-by-line read in of a netlist until the .end card is found or alternatively the EOF character is returned.","title":"Standard Input"},{"location":"syntax/#constants","text":"JoSIM has a set of built in constants that when used expand to the corresponding values. Below is a list of these constants and their values. The constants names are case insensitive: Constant Symbol Value PI \\(\\pi\\) 3.141592653589793238463 PHI_ZERO \\(\\Phi_{0}\\) 2.067833831170082E-15 BOLTZMANN \\(k_{B}\\) 1.38064852E-23 EV \\(e\\) 1.6021766208E-19 HBAR \\(\\bar{h}\\) 1.0545718001391127E-34 C \\(c\\) 299792458 MU0 \\(\\mu_{0}\\) 12.566370614E-7 EPS0 \\(\\epsilon_{0}\\) 8.854187817E-12 SIGMA \\(\\sigma\\) (short for \\(\\frac{\\Phi_{0}}{2\\pi}\\) ) 3.291059757E-16","title":"Constants"},{"location":"tech_disc/","text":"Technical Discussion This section of the documentation is dedicated to providing the user with better understanding of the internal operations of JoSIM. As mentioned, this section will follow the sections of the macro overview, providing more detail to each block. Input circuit file JoSIM requires an input file that follows the syntax as stipulated in the Syntax Guideline . This input file further requires a single transient analysis command which instructs the simulation engine what to do with the rest of the input file. This input file does not require a specific extension, but a .cir extension is recommended to fit with universal circuit simulation standards. Additionally, JoSIM allows the user the capability to feed input from standard input using the -i switch when running josim-cli . This command instructs JoSIM to read input from the command line, line by line, until the .end control card is received. This is ideal in a case where the output from another program is piped to josim-cli . CLI Options When josim-cli is used, JoSIM needs to check and handle any command line options that the user provided before continuing to parse the input . A CLI Options object is created from the handled command line options and fed to the input parser along with the input data. A list of available command line options can be displayed using the -h , but each command what action is performed by it is discussed here. Running -h produces the following: Analysis (-a): This command specifies which analysis type is used by JoSIM. This can be either 0 for voltage analysis or 1 for phase analysis. Phase mode has been made the default mode of analysis as of version 2.5. The differences between these methods are discussed in the modified nodal analysis section. Help (-h): Displays the above help menu and immediately exits the program. If this command is provided with any other command, this command takes precedence. Input (-i): As mentioned before, JoSIM has the capability to receive input from the command line interface (standard input) line by line. This command ignores any additional input files specified and stops reading once the .end command or an EOF (platform specific) character is received. Minimal (-m): To prevent JoSIM from printing any unnecessary output to the command interface, such as progress indicators. This does not mute verbose output. Output (-o): Specifies the filename and type (through extension) of the output file where results will be stored. By default, if -o is specified and no filename is provided, a output.csv file is produced. The available file formats are discussed in detail in the output results section. Parallel (-p): As of version 2.5 there are currently no sections of JoSIM that are parallel processed. This option, when enabled, checks whether JoSIM was compiled with --DUSING_OPENMP=1 CMake switch. This is reserved for future implementation of very large circuits. At present, does nothing and not detrimental to performance in any scenario. Verbose (-V): This enables different levels of verbosity by the simulator. Level 1 verbosity only displays statistics of the circuit being simulated. Level 2 verbosity displays all of level 1 and any evaluated .param statements found in the circuit. Level 3 verbosity displays level 2 and the completely expanded main design of circuit being simulated. These outputs are not muted by -m Version (-v): Only displays the version string for josim-cli and then exits. This string is always displayed by default for any command. This command, however, only displays the version string. Solver (-x): This option allows switching between LU solvers. Default is KLU solver. Setting this to 1 enables SuperLU solver. Parse Input The input data received through any of the two means above is parsed in the following steps: Read Input Each line in the input data is taken and cast to uppercase to avoid ambiguity. This is very important to note, JoSIM is CaSe InSeNsItIvE , meaning that any syntactical identifiers in the data with different case are seen as the same. Each line is further tokenized by space white spaces, this allows JoSIM to remove any ambiguity to spacing and positional info in the input data. If the line is blank or begins with a * (asterisk) or # (hash) character, this line is ignored and not processed. Lines that begin with a + (plus) character are treated internally as part of the previously processed lines. In JoSIM, this means that the processed tokens from this line are added to the end of the tokens of the previous line. Furthermore, this section handles any type of .include statement. This control allows for inclusion of other files immediately into the currently being processed data. This is extremely handy when a set of subcircuits that are used across multiple files (such as a cell library) are stored in a central location and simply included in each file where needed. This centralizes changes and reduces fragmentation of subcircuits. Please see the include section of the syntax guideline. Parse Input The list of tokens created from the previous process are now further processed by sorting each line into either controls, parameters, subcircuits or main design. This is performed by taking a look at the first token of each item in the list. If the is a .subckt or .ends card, this signals the start or end of a subcircuit respectively. Each line between these list items are added to a subcircuit object. If the token is a .param token, this list item is added to the parameters list. Lines that begin with .model are added to the list of models. Further, if the token starts with a . (period) but is not either of the above then it is a normal control and added to the controls list. Lastly, if it isn't any of the above it is added to the main design object. Further information on any of these parts can be found in the syntax section. Parameters Any identified parameters are recursively parsed until there aren't any unparsed parameters remaining. If it is exhaustively parsed but there are remaining parameters, an error is thrown for undefined parameters. With the proper syntax each parameter is passed to a custom implementation of Dijkstra's shunting yard algorithm 1 . This algorithm returns the processed value and attaches it to the relevant variable name. Parameters are unique to subcircuits, which means that during parsing a parameter is checked to see what subcircuit it belongs to. If it does not belong to any, it is seen as a global parameter. This allows subcircuits to have unique values for parameters while retaining the same variable name. Models Models identified are processed and checked for syntax. If any model does not comply with recognized syntax, JoSIM halts with an error. At present the only supported model is the Josephson junction model. This is covered in the Josephson junction part of the syntax guide. Expanding Subcircuits This section only acts to check that subcircuits are not more than 1 level deep. By this, we mean that nested subcircuits need to be flattened to a point where they are only one level deep. To achieve this, a recursive check is done to see if any subcircuit contains a list item that begins with a X (subcircuit identifier). By traversing the nest to the deepest level and expanding backwards we are able to arrive at a list of subcircuits that are not nested. The process of expansion is done by taking the device label (token that starts with an X ) as the subcircuit name. This is then appended to all labels of the identified flattened subcircuit as well as the nodes by means of a | (vertical bar) followed by the name. During this process, the I/O (Input Output) nodes are identified and replaced by their respective nodes for the circuit they belong to. With each level the name of the parent subcircuit is appended to the name of the current subcircuit name. This is shown in detail in the expanding main design section with an example. Expanding Main Design Each circuit requires a main design, which is a circuit netlist that is not a subcircuit and contains some form of input and output. Any subcircuits that were flattened in the previous section are populated into the main design using the same method of appending the subcircuit name to device labels and node names. To illustrate what is meant by this process we provide a small example. First we show a compact netlist. Note: this is purely for illustration and does not represent any form of working circuitry. # Subcircuit .subckt RLC IN OUT R01 IN 1 2 L01 1 2 2pH C01 2 OUT 2uF .ends # Nested subcircuit .subckt RRLCLC IN OUT R01 IN 1 2 X01 1 2 RLC L01 2 3 2pH C01 3 OUT 2uF .ends # Main design V01 1 0 DC 5V X02 1 2 RRLCLC R01 2 0 2 .tran 0.25p 500p This very basic circuit shows that there is a subcircuit that is nested within another subcircuit that is used in the main design. When expanded the main design becomes: V01 1 0 DC 5V R01|X02 1 1|X02 2 R01|X01|X02 1|X02 1|X01|X02 2 L01|X01|X02 1|X01|X02 2|X01|X02 2PH C01|X01|X02 2|X01|X02 2|X02 2UF L01|X02 2|X02 3|X02 2PH C01|X02 3|X02 2 2UF R01 2 0 2 .TRAN 0.25P 500P This might seem bizarre and rather complex but it allows each node name and label to be unique within the larger main design. This further simplifies saving results for specific devices that are nested deep within the circuit. Further information on saving results is provided in the output section of the syntax guide. Identify Simulation Lastly, a netlist requires a simulation command to be able to do work. JoSIM only supports transient simulation method at present. This requires the presence of a .tran command that follows the correct syntax. See transient simulation for more information on the syntax. Noise Insertion As of version 2.5, JoSIM has the capability to add thermal noise to the circuit through a current source in parallel to each resistor (heat generating element). If a the .temp control was found in the controls list during parsing this function is triggered. This scans through the entire expanded main design, adding current sources in parallel to each resistor using the following equation 2 : \\[ I_n=\\sqrt{\\frac{4k_{B}T}{R}} \\] In this equation, T is the temperature provided by the .temp control in Kelvin, R is the resistance and \\(k_{B}\\) is the Boltzmann constant. This equation provides the noise spectral amplitude to for the noise source. Further information on noise sources , and the syntax thereof, can be found in the syntax guide. It is important to note that subcircuits cannot contain a .temp command. A warning will be thrown and the command ignored. Create Matrix The matrix creation process follows the steps set out in the overview depicted below. Create Components The expanded main design is iterated through, identifying the type of component each line represents through the first character. An object is created for each component storing relevant information such as the node numbers, label, value, non-zeros, etc. A list of available components based on the first character is shown below. Any line starting with a character not listed below will cause an error and program termination. Character Component B Junction (at present only Josephson) C Capacitor E Voltage Controlled Voltage Source (VCVS) F Current Controlled Current Source (CCCS) G Voltage Controlled Current Source (VCCS) H Current Controlled Voltage Source (CCVS) I Current Source K Mutual Inductance L Inductor P Phase Source R Resistor T Transmission Line V Voltage Source Syntax for each of these components can be found in the relevant sections of the syntax guide. The matrix is set up using the modified nodal analysis . Modified nodal analysis There are many ways to set up a set of linear equations to solve the voltage or currents in a circuit. One of the more well known ways is to use nodal analysis which creates an equation for each node defined in the circuit netlist. This method is the basis on which the original Berkeley SPICE 3 was built. This method, however, only calculates the voltages of every node which makes it difficult to handle components that are voltage dependent such as inductors and junctions. This drawback led to the creation of the modified nodal analysis (MNA) which is an extension to the prior with the ability to calculating branch currents in addition to nodal voltages 4 . We therefore make use of the MNA method to build the set of linear equations within JoSIM due to the large use of inductors as well as Josephson junctions in superconductivity. A useful feature of the MNA method allows every component to be represented as a sub-matrix called a stamp. The summation of all the stamps provide us with the A , x as well as b matrices that are required to solve the linear equations. These stamps will be discussed further in the following subsection. Backward Differentiation Formula In transient analysis many components have time dependent \\((\\frac{d}{dt})\\) voltage or current values. These differentials are not easily solvable and require special techniques to approximate the value at the requested time given previous time values. One such method is the backward differential formula (BDF) 5 , which is a linear multistep method. In circuit analysis applications, the BDF2 (2nd order) method is considered the most stable method. This method is expressed as: \\[ \\left(\\frac{dx}{dt}\\right)_n = \\frac{3}{2h}\\left[x_n - \\frac{4}{3}x_{n-1} + \\frac{1}{3}x_{n\u22122}\\right] \\] With \\(h\u200b\\) as the time difference or rather time step of the simulation. This method requires knowledge of 2 prior timesteps, indicated by \\(n-1\\) and \\(n-2\\) . Though this method might seem like it requires extra computation for every component, it actually simplifies components that require differentials. We demonstrate this using the capacitor. The capacitor above has a general equation to determine the current through it as: \\[ i_{C_{1}}(t) = C_{1}\\frac{dv}{dt} \\] It is noted that this equation is time dependent and we therefore need to apply the BDF2 method: \\[ I_{C1} = \\frac{3C_{1}}{2h}\\left[V_{n}-\\frac{4}{3}V_{n-1}+\\frac{1}{3}V_{n-2}\\right] \\] We note that the \\(V\\) is the difference in voltage across the component and taken as \\(V_{1} - V_{2}\\) . We further expand the above equation to place values of the current time step on the left hand side (LHS) and all known values on the right hand side (RHS): \\[ \\frac{3C_{1}}{2h}V_{n} - I_{C_{1}} = \\frac{2C_{1}}{h}V_{n-1} - \\frac{C_{1}}{2h}V_{n-2} \\] \\[ V_{n} - \\frac{2h}{3C_{1}}I_{C_{1}} = \\frac{2h}{3C_{1}}\\frac{2C_{1}}{h}V_{n-1}-\\frac{2h}{3C_{1}}\\frac{C_{1}}{2h}V_{n-2} \\] \\[ V_{n} - \\frac{2h}{3C_{1}}I_{C_{1}} = \\frac{4}{3}V_{n-1}-\\frac{1}{3}V_{n-2} \\] Which we can then write in matrix form as: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{2h}{3C_{1}} \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ I_{C_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{4}{3}V_{n-1}-\\frac{1}{3}V_{n-2} \\end{bmatrix} \\] The matrix above is a generic stamp that we can place into the A matrix which describes the capacitor \\(C_{1}\\) . Modified nodal phase analysis First introduced in version 2.0, the ability to perform a simulation that calculates the nodal phase instead of voltage was implemented. This new analysis method is named the modified nodal phase analysis (MNPA) and utilizes the voltage-phase 6 relationship seen below. \\[ v = \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt} \\] If this relationship is applied to all the component models found in JoSIM we obtain the MNPA stamps, which allow us to solve the phase directly. As example we demonstrate this on the capacitor equation shown in the previous section. \\[ I_{C1} = \\frac{3C_{1}}{2h}\\left[\\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}-\\frac{4}{3}\\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}_{n-1}+\\frac{1}{3}\\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}_{n-2}\\right] \\] \\[ I_{C1} = \\frac{3C_{1}}{2h}\\frac{\\Phi_{0}}{2\\pi}\\left[\\frac{d\\phi}{dt}-\\frac{4}{3}\\frac{d\\phi}{dt}_{n-1}+\\frac{1}{3}\\frac{d\\phi}{dt}_{n-2}\\right] \\] \\[ \\frac{2h}{3C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{d\\phi}{dt}-\\frac{4}{3}\\frac{d\\phi}{dt}_{n-1}+\\frac{1}{3}\\frac{d\\phi}{dt}_{n-2} \\] \\[ \\frac{2h}{3C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{3}{2h}\\left[\\phi_n - \\frac{4}{3}\\phi_{n-1}+\\frac{1}{3}\\phi_{n-2}\\right]-\\frac{4}{3}\\frac{3}{2h}\\left[\\phi_{n-1} - \\frac{4}{3}\\phi_{n-2}+\\frac{1}{3}\\phi_{n-3}\\right]+\\frac{1}{3}\\frac{3}{2h}\\left[\\phi_{n-2} - \\frac{4}{3}\\phi_{n-3}+\\frac{1}{3}\\phi_{n-4}\\right] \\] \\[ \\frac{2h}{3C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{3}{2h}\\phi_n - \\frac{2}{h}\\phi_{n-1}-\\frac{2}{h}\\phi_{n-1}+\\frac{1}{2h}\\phi_{n-2} + \\frac{8}{3h}\\phi_{n-2}+\\frac{1}{2h}\\phi_{n-2}-\\frac{2}{3h}\\phi_{n-3} - \\frac{2}{3h}\\phi_{n-3}+\\frac{1}{6h}\\phi_{n-4} \\] \\[ \\frac{2h}{3C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{3}{2h}\\phi_n - \\frac{4}{h}\\phi_{n-1} + \\frac{22}{6h}\\phi_{n-2}-\\frac{4}{3h}\\phi_{n-3}+\\frac{1}{6h}\\phi_{n-4} \\] \\[ \\phi_n - \\frac{4h^{2}}{9C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{8}{3}\\phi_{n-1} - \\frac{22}{9}\\phi_{n-2}+\\frac{8}{9}\\phi_{n-3}-\\frac{1}{9}\\phi_{n-4} \\] This can then be reduced to a component stamp as follows: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{4h^{2}}{9C_{1}}\\frac{2\\pi}{\\Phi_{0}} \\end{bmatrix} \\begin{bmatrix} \\phi^{+} \\\\ \\phi^{-} \\\\ I_{C_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{8}{3}\\phi_{n-1} - \\frac{22}{9}\\phi_{n-2}+\\frac{8}{9}\\phi_{n-3}-\\frac{1}{9}\\phi_{n-4} \\end{bmatrix} \\] With this expansion it is shown, the capacitor requires up to 4 previous time step values to compute the current step. JoSIM has been adapted to allow phase analysis on any design that works with voltage analysis without requiring alterations to the netlist file. Since the voltage is simply the scaled time derivative of the phase the voltage can be calculated as a post process if the user requests it. As noted in the CLI Options section, the default mode for simulation is now phase as of version 2.5. All the MNPA stamps are included in the Component Stamps section. Mutual Inductances If there are any mutual inductances in the circuit then this section is triggered. When found in the previous section the mutual inductances are simply added to a list for later processing. This is done to allow all inductors to be created as objects first before the mutual inductors are applied. This also allows us to perform a sanity check, ensuring that the inductors being coupled exist. Create CSR The concept of zero is a strange thing, to humans it is nothing but to machines it is the same as all other numbers and takes up just as much memory. Since we do not want to waste memory and computation storing the number zero we use a different form of matrix representation known as the compressed row storage (CSR) 7 . This data structure consists of 3 vectors, namely the non-zero (nnz), the column indices (ci) and the row pointer (rp) vectors. The non-zero vector only stores the non-zero elements of each component. The column indices vector stores the index where each of the non-zeros are found. The row pointer stores the total number of non-zeros after each row, starting with zero. This allows the simulation engine to quickly discern which non-zero belongs in which position if the matrix were actually a full sparse matrix. As example to demonstrate this we use the following 5x5 matrix: \\[ \\begin{bmatrix} 1 & 0 & 0 & 4 & 0\\\\ 0 & 3 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0\\\\ 0& 4 & 0 & 5 & 0 \\\\ 0 & 0 & 0 & 0 & 1 \\end{bmatrix} \\] Storing this matrix in system memory would take up 25 numbers. If we were to convert this to CSR format we arrive at the following 3 vectors: \\[ nnz=\\left[1, 4, 3, 1, 4, 5, 1\\right] \\] \\[ ci=\\left[0,3,1,2,1,3,4\\right] \\] \\[ rp=\\left[0,2,3,4,6,7\\right] \\] This data structure only takes up 20 numbers to store. This does not seem much less than the 25 before, but this scales very significantly when working with very large circuits. During the matrix creation part, the objects created already form these nnz, ci and rp vectors for each component. During this part all these vectors are simply collected to form the overall CSR for the circuit. Find Relevant Traces Like before with the CSR instead of storing the full matrix to save memory, it would also be advantageous to not store every value computed during the simulation step for every component. To avoid this, we identify the specific traces (reference to relevant computed values) before simulation starts. This is done by combing the controls list for any output statements ( .print , .plot or .save ) and identifying which component or node each refer to. The relevant node and current branch indices are then stored in a list which will be used during simulation. Simulation Once we have a all the component objects and a CSR representing the matrix we can perform the requested simulation. An overview of the simulation step is shown below. Create Simulation Objects JoSIM uses the sparse matrix solver library SuiteSparse 8 of which the KLU solver is implemented. To use KLU specific objects need to be created using the CSR vectors. During this part these objects are created and initialized using the relevant data. Start Simulation A transient simulation is synonymous to a time domain simulation, and since we are working with a digital system this time simulation needs to be discretized into a set amount of steps determined by the total simulation time divided by the step size. Create b Matrix The b matrix is created using the known values from each component's RHS of the equation. All components are itterated through and their RHS values inserted into the b matrix at the correct locations before simulation is done. Solve Ax=b With both A and b known, KLU solves x (the unknowns) for the current step. Store results The results in x are iterated, storing only the relevant trace data as previously determined. The implementation of a transmission line in JoSIM is only a scaled time delay at present and as such the currents of and nodes connected to all transmission lines need to be stored for all time. Once completed, the process is repeated for the next time step until the simulation is finished. Output Results The results from the simulation along with the time data is formatted to form a 2D data set with a label describing each column of data. JoSIM supports exactly 3 output formats. Each of which are determined by the extension of the file specified in the CLI Options . These formats are comma separated value (CSV), space separated value (DAT) and raw SPICE output. CSV (.csv) The formatted results are stored in a file with the labels at the top followed by each row of data starting with the time point. All elements in this file are comma separated. This makes it very easy to read and understand from a human perspective but as well by many software libraries for plotting. This is also the default format in the case that output was requested but no file name provided. In this case the results will be stored in a file called output.csv . DAT (.dat) Very similar to the CSV file but instead of commas, spaces are used. This is a legacy format used as output by older simulators such as JSIM. RAW (no extension) If no extension is given for the file name then a RAW SPICE file will be created. This is a very specifically formatted file that specifies the variables in a list, followed by a time step and each variable's data for that time point. This format is understood by many SPICE output plotting tools. Plotting interfaces In previous versions of JoSIM there existed 2 plotting windows, namely FLTK and Matplotlib. These interfaces were, however, ultimately scrapped due to maintainability issues as well as cross-platform compatibility. The user is requested to use the plotting system they are most comfortable with. Below we provide a simple Python 3 script that plots all the results in a .csv file. It is very basic and the user should modify it as required. This script requires installation of the Numpy as well as Matplotlib packages for Python 3. Optionally, we comment the lines for use of the Qt5 backend for plotting. The user can enable this if the PyQt5 package is installed. A Plotly and Pandas script is provided in the scripts folder of the GitHub repository that visualizes the results in a much more elegant way, with many more settings that can be adjusted by the user. #!/usr/bin/env python import math # import matplotlib # matplotlib.use('Qt5Agg') import matplotlib.pyplot as pl from matplotlib import gridspec import numpy as np import csv import sys time = [] data = [] labels = set () with open ( sys . argv [ 1 ], 'r' ) as csvFile : reader = csv . DictReader ( csvFile ) labels = reader . fieldnames data . append ([]) for row in reader : time . append ( float ( row [ labels [ 0 ]])) for var in range ( 1 , len ( labels )): data . append ([]) data [ var ] . append ( float ( row [ labels [ var ]])) csvFile . close () N = len ( labels ) - 1 cols = int ( math . ceil ( N / 4 )) rows = int ( math . ceil ( N / cols )) gs = gridspec . GridSpec ( rows , cols ) fig = pl . figure () for var in range ( 1 , len ( labels )): ax = fig . add_subplot ( gs [ var - 1 ]) ax . plot ( time , data [ var ]) ax . set_xlabel ( labels [ 0 ]) ax . set_ylabel ( labels [ var ]) fig . set_tight_layout ( True ) fig . show () input () E. W. Dijkstra, \"Algol 60 translation : An Algol 60 translator for the x1 and Making a translator for Algol 60\" in MR35, Mathematisch Centrum, Amsterdam , 1961 \u21a9 J. Satchell, \"Limitations on HTS single flux quantum logic,\" in IEEE Transactions on Applied Superconductivity , vol. 9, no. 2, pp. 3841-3844, June 1999, doi: 10.1109/77.783865 \u21a9 L. Nagel, \"Spice: A computer program to simulate computer circuits\" in University of California, Berkeley UCB/ERL Memo M520 , pp. 201-204, 1995 \u21a9 C. Ho, A. Ruehli, & P. Brennan, \"The modified nodal approach to network analysis\" in IEEE Transactions on circuits and systems , vol. 22, no. 6, pp. 506-509, 1975 \u21a9 C. F. Curtiss, & J. O. Hirschfelder, \"Integration of stiff equations\" in Proceedings of the National Academy of Sciences , vol. 38, no. 3, pp. 235-243, 1952 \u21a9 T. P. Orlando & K. A. Delin, \"Foundations of Applied Superconductivity\", Addison-Wesley Reading, MA vol. 8, 1991 \u21a9 A. Bulu, J. T. Fineman, M. Frigo, J. R. Gilbert and C. E. Leiserson, \"Parallel sparse matrix-vector and matrix-transpose-vector multiplication using compressed sparse blocks\" in Proceedings of the twenty-first annual symposium on Parallelism in algorithms and architectures , pp. 233-244, 2009 \u21a9 T. A. Davis, \"Direct methods for sparse linear systems\", SIAM, Philadelphia, 2006 \u21a9","title":"Technical Discussion"},{"location":"tech_disc/#technical-discussion","text":"This section of the documentation is dedicated to providing the user with better understanding of the internal operations of JoSIM. As mentioned, this section will follow the sections of the macro overview, providing more detail to each block.","title":"Technical Discussion"},{"location":"tech_disc/#input-circuit-file","text":"JoSIM requires an input file that follows the syntax as stipulated in the Syntax Guideline . This input file further requires a single transient analysis command which instructs the simulation engine what to do with the rest of the input file. This input file does not require a specific extension, but a .cir extension is recommended to fit with universal circuit simulation standards. Additionally, JoSIM allows the user the capability to feed input from standard input using the -i switch when running josim-cli . This command instructs JoSIM to read input from the command line, line by line, until the .end control card is received. This is ideal in a case where the output from another program is piped to josim-cli .","title":"Input circuit file"},{"location":"tech_disc/#cli-options","text":"When josim-cli is used, JoSIM needs to check and handle any command line options that the user provided before continuing to parse the input . A CLI Options object is created from the handled command line options and fed to the input parser along with the input data. A list of available command line options can be displayed using the -h , but each command what action is performed by it is discussed here. Running -h produces the following:","title":"CLI Options"},{"location":"tech_disc/#analysis-a","text":"This command specifies which analysis type is used by JoSIM. This can be either 0 for voltage analysis or 1 for phase analysis. Phase mode has been made the default mode of analysis as of version 2.5. The differences between these methods are discussed in the modified nodal analysis section.","title":"Analysis (-a):"},{"location":"tech_disc/#help-h","text":"Displays the above help menu and immediately exits the program. If this command is provided with any other command, this command takes precedence.","title":"Help (-h):"},{"location":"tech_disc/#input-i","text":"As mentioned before, JoSIM has the capability to receive input from the command line interface (standard input) line by line. This command ignores any additional input files specified and stops reading once the .end command or an EOF (platform specific) character is received.","title":"Input (-i):"},{"location":"tech_disc/#minimal-m","text":"To prevent JoSIM from printing any unnecessary output to the command interface, such as progress indicators. This does not mute verbose output.","title":"Minimal (-m):"},{"location":"tech_disc/#output-o","text":"Specifies the filename and type (through extension) of the output file where results will be stored. By default, if -o is specified and no filename is provided, a output.csv file is produced. The available file formats are discussed in detail in the output results section.","title":"Output (-o):"},{"location":"tech_disc/#parallel-p","text":"As of version 2.5 there are currently no sections of JoSIM that are parallel processed. This option, when enabled, checks whether JoSIM was compiled with --DUSING_OPENMP=1 CMake switch. This is reserved for future implementation of very large circuits. At present, does nothing and not detrimental to performance in any scenario.","title":"Parallel (-p):"},{"location":"tech_disc/#verbose-v","text":"This enables different levels of verbosity by the simulator. Level 1 verbosity only displays statistics of the circuit being simulated. Level 2 verbosity displays all of level 1 and any evaluated .param statements found in the circuit. Level 3 verbosity displays level 2 and the completely expanded main design of circuit being simulated. These outputs are not muted by -m","title":"Verbose (-V):"},{"location":"tech_disc/#version-v","text":"Only displays the version string for josim-cli and then exits. This string is always displayed by default for any command. This command, however, only displays the version string.","title":"Version (-v):"},{"location":"tech_disc/#solver-x","text":"This option allows switching between LU solvers. Default is KLU solver. Setting this to 1 enables SuperLU solver.","title":"Solver (-x):"},{"location":"tech_disc/#parse-input","text":"The input data received through any of the two means above is parsed in the following steps:","title":"Parse Input"},{"location":"tech_disc/#read-input","text":"Each line in the input data is taken and cast to uppercase to avoid ambiguity. This is very important to note, JoSIM is CaSe InSeNsItIvE , meaning that any syntactical identifiers in the data with different case are seen as the same. Each line is further tokenized by space white spaces, this allows JoSIM to remove any ambiguity to spacing and positional info in the input data. If the line is blank or begins with a * (asterisk) or # (hash) character, this line is ignored and not processed. Lines that begin with a + (plus) character are treated internally as part of the previously processed lines. In JoSIM, this means that the processed tokens from this line are added to the end of the tokens of the previous line. Furthermore, this section handles any type of .include statement. This control allows for inclusion of other files immediately into the currently being processed data. This is extremely handy when a set of subcircuits that are used across multiple files (such as a cell library) are stored in a central location and simply included in each file where needed. This centralizes changes and reduces fragmentation of subcircuits. Please see the include section of the syntax guideline.","title":"Read Input"},{"location":"tech_disc/#parse-input_1","text":"The list of tokens created from the previous process are now further processed by sorting each line into either controls, parameters, subcircuits or main design. This is performed by taking a look at the first token of each item in the list. If the is a .subckt or .ends card, this signals the start or end of a subcircuit respectively. Each line between these list items are added to a subcircuit object. If the token is a .param token, this list item is added to the parameters list. Lines that begin with .model are added to the list of models. Further, if the token starts with a . (period) but is not either of the above then it is a normal control and added to the controls list. Lastly, if it isn't any of the above it is added to the main design object. Further information on any of these parts can be found in the syntax section.","title":"Parse Input"},{"location":"tech_disc/#parameters","text":"Any identified parameters are recursively parsed until there aren't any unparsed parameters remaining. If it is exhaustively parsed but there are remaining parameters, an error is thrown for undefined parameters. With the proper syntax each parameter is passed to a custom implementation of Dijkstra's shunting yard algorithm 1 . This algorithm returns the processed value and attaches it to the relevant variable name. Parameters are unique to subcircuits, which means that during parsing a parameter is checked to see what subcircuit it belongs to. If it does not belong to any, it is seen as a global parameter. This allows subcircuits to have unique values for parameters while retaining the same variable name.","title":"Parameters"},{"location":"tech_disc/#models","text":"Models identified are processed and checked for syntax. If any model does not comply with recognized syntax, JoSIM halts with an error. At present the only supported model is the Josephson junction model. This is covered in the Josephson junction part of the syntax guide.","title":"Models"},{"location":"tech_disc/#expanding-subcircuits","text":"This section only acts to check that subcircuits are not more than 1 level deep. By this, we mean that nested subcircuits need to be flattened to a point where they are only one level deep. To achieve this, a recursive check is done to see if any subcircuit contains a list item that begins with a X (subcircuit identifier). By traversing the nest to the deepest level and expanding backwards we are able to arrive at a list of subcircuits that are not nested. The process of expansion is done by taking the device label (token that starts with an X ) as the subcircuit name. This is then appended to all labels of the identified flattened subcircuit as well as the nodes by means of a | (vertical bar) followed by the name. During this process, the I/O (Input Output) nodes are identified and replaced by their respective nodes for the circuit they belong to. With each level the name of the parent subcircuit is appended to the name of the current subcircuit name. This is shown in detail in the expanding main design section with an example.","title":"Expanding Subcircuits"},{"location":"tech_disc/#expanding-main-design","text":"Each circuit requires a main design, which is a circuit netlist that is not a subcircuit and contains some form of input and output. Any subcircuits that were flattened in the previous section are populated into the main design using the same method of appending the subcircuit name to device labels and node names. To illustrate what is meant by this process we provide a small example. First we show a compact netlist. Note: this is purely for illustration and does not represent any form of working circuitry. # Subcircuit .subckt RLC IN OUT R01 IN 1 2 L01 1 2 2pH C01 2 OUT 2uF .ends # Nested subcircuit .subckt RRLCLC IN OUT R01 IN 1 2 X01 1 2 RLC L01 2 3 2pH C01 3 OUT 2uF .ends # Main design V01 1 0 DC 5V X02 1 2 RRLCLC R01 2 0 2 .tran 0.25p 500p This very basic circuit shows that there is a subcircuit that is nested within another subcircuit that is used in the main design. When expanded the main design becomes: V01 1 0 DC 5V R01|X02 1 1|X02 2 R01|X01|X02 1|X02 1|X01|X02 2 L01|X01|X02 1|X01|X02 2|X01|X02 2PH C01|X01|X02 2|X01|X02 2|X02 2UF L01|X02 2|X02 3|X02 2PH C01|X02 3|X02 2 2UF R01 2 0 2 .TRAN 0.25P 500P This might seem bizarre and rather complex but it allows each node name and label to be unique within the larger main design. This further simplifies saving results for specific devices that are nested deep within the circuit. Further information on saving results is provided in the output section of the syntax guide.","title":"Expanding Main Design"},{"location":"tech_disc/#identify-simulation","text":"Lastly, a netlist requires a simulation command to be able to do work. JoSIM only supports transient simulation method at present. This requires the presence of a .tran command that follows the correct syntax. See transient simulation for more information on the syntax.","title":"Identify Simulation"},{"location":"tech_disc/#noise-insertion","text":"As of version 2.5, JoSIM has the capability to add thermal noise to the circuit through a current source in parallel to each resistor (heat generating element). If a the .temp control was found in the controls list during parsing this function is triggered. This scans through the entire expanded main design, adding current sources in parallel to each resistor using the following equation 2 : \\[ I_n=\\sqrt{\\frac{4k_{B}T}{R}} \\] In this equation, T is the temperature provided by the .temp control in Kelvin, R is the resistance and \\(k_{B}\\) is the Boltzmann constant. This equation provides the noise spectral amplitude to for the noise source. Further information on noise sources , and the syntax thereof, can be found in the syntax guide. It is important to note that subcircuits cannot contain a .temp command. A warning will be thrown and the command ignored.","title":"Noise Insertion"},{"location":"tech_disc/#create-matrix","text":"The matrix creation process follows the steps set out in the overview depicted below.","title":"Create Matrix"},{"location":"tech_disc/#create-components","text":"The expanded main design is iterated through, identifying the type of component each line represents through the first character. An object is created for each component storing relevant information such as the node numbers, label, value, non-zeros, etc. A list of available components based on the first character is shown below. Any line starting with a character not listed below will cause an error and program termination. Character Component B Junction (at present only Josephson) C Capacitor E Voltage Controlled Voltage Source (VCVS) F Current Controlled Current Source (CCCS) G Voltage Controlled Current Source (VCCS) H Current Controlled Voltage Source (CCVS) I Current Source K Mutual Inductance L Inductor P Phase Source R Resistor T Transmission Line V Voltage Source Syntax for each of these components can be found in the relevant sections of the syntax guide. The matrix is set up using the modified nodal analysis .","title":"Create Components"},{"location":"tech_disc/#modified-nodal-analysis","text":"There are many ways to set up a set of linear equations to solve the voltage or currents in a circuit. One of the more well known ways is to use nodal analysis which creates an equation for each node defined in the circuit netlist. This method is the basis on which the original Berkeley SPICE 3 was built. This method, however, only calculates the voltages of every node which makes it difficult to handle components that are voltage dependent such as inductors and junctions. This drawback led to the creation of the modified nodal analysis (MNA) which is an extension to the prior with the ability to calculating branch currents in addition to nodal voltages 4 . We therefore make use of the MNA method to build the set of linear equations within JoSIM due to the large use of inductors as well as Josephson junctions in superconductivity. A useful feature of the MNA method allows every component to be represented as a sub-matrix called a stamp. The summation of all the stamps provide us with the A , x as well as b matrices that are required to solve the linear equations. These stamps will be discussed further in the following subsection.","title":"Modified nodal analysis"},{"location":"tech_disc/#backward-differentiation-formula","text":"In transient analysis many components have time dependent \\((\\frac{d}{dt})\\) voltage or current values. These differentials are not easily solvable and require special techniques to approximate the value at the requested time given previous time values. One such method is the backward differential formula (BDF) 5 , which is a linear multistep method. In circuit analysis applications, the BDF2 (2nd order) method is considered the most stable method. This method is expressed as: \\[ \\left(\\frac{dx}{dt}\\right)_n = \\frac{3}{2h}\\left[x_n - \\frac{4}{3}x_{n-1} + \\frac{1}{3}x_{n\u22122}\\right] \\] With \\(h\u200b\\) as the time difference or rather time step of the simulation. This method requires knowledge of 2 prior timesteps, indicated by \\(n-1\\) and \\(n-2\\) . Though this method might seem like it requires extra computation for every component, it actually simplifies components that require differentials. We demonstrate this using the capacitor. The capacitor above has a general equation to determine the current through it as: \\[ i_{C_{1}}(t) = C_{1}\\frac{dv}{dt} \\] It is noted that this equation is time dependent and we therefore need to apply the BDF2 method: \\[ I_{C1} = \\frac{3C_{1}}{2h}\\left[V_{n}-\\frac{4}{3}V_{n-1}+\\frac{1}{3}V_{n-2}\\right] \\] We note that the \\(V\\) is the difference in voltage across the component and taken as \\(V_{1} - V_{2}\\) . We further expand the above equation to place values of the current time step on the left hand side (LHS) and all known values on the right hand side (RHS): \\[ \\frac{3C_{1}}{2h}V_{n} - I_{C_{1}} = \\frac{2C_{1}}{h}V_{n-1} - \\frac{C_{1}}{2h}V_{n-2} \\] \\[ V_{n} - \\frac{2h}{3C_{1}}I_{C_{1}} = \\frac{2h}{3C_{1}}\\frac{2C_{1}}{h}V_{n-1}-\\frac{2h}{3C_{1}}\\frac{C_{1}}{2h}V_{n-2} \\] \\[ V_{n} - \\frac{2h}{3C_{1}}I_{C_{1}} = \\frac{4}{3}V_{n-1}-\\frac{1}{3}V_{n-2} \\] Which we can then write in matrix form as: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{2h}{3C_{1}} \\end{bmatrix} \\begin{bmatrix} V^{+} \\\\ V^{-} \\\\ I_{C_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{4}{3}V_{n-1}-\\frac{1}{3}V_{n-2} \\end{bmatrix} \\] The matrix above is a generic stamp that we can place into the A matrix which describes the capacitor \\(C_{1}\\) .","title":"Backward Differentiation Formula"},{"location":"tech_disc/#modified-nodal-phase-analysis","text":"First introduced in version 2.0, the ability to perform a simulation that calculates the nodal phase instead of voltage was implemented. This new analysis method is named the modified nodal phase analysis (MNPA) and utilizes the voltage-phase 6 relationship seen below. \\[ v = \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt} \\] If this relationship is applied to all the component models found in JoSIM we obtain the MNPA stamps, which allow us to solve the phase directly. As example we demonstrate this on the capacitor equation shown in the previous section. \\[ I_{C1} = \\frac{3C_{1}}{2h}\\left[\\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}-\\frac{4}{3}\\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}_{n-1}+\\frac{1}{3}\\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt}_{n-2}\\right] \\] \\[ I_{C1} = \\frac{3C_{1}}{2h}\\frac{\\Phi_{0}}{2\\pi}\\left[\\frac{d\\phi}{dt}-\\frac{4}{3}\\frac{d\\phi}{dt}_{n-1}+\\frac{1}{3}\\frac{d\\phi}{dt}_{n-2}\\right] \\] \\[ \\frac{2h}{3C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{d\\phi}{dt}-\\frac{4}{3}\\frac{d\\phi}{dt}_{n-1}+\\frac{1}{3}\\frac{d\\phi}{dt}_{n-2} \\] \\[ \\frac{2h}{3C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{3}{2h}\\left[\\phi_n - \\frac{4}{3}\\phi_{n-1}+\\frac{1}{3}\\phi_{n-2}\\right]-\\frac{4}{3}\\frac{3}{2h}\\left[\\phi_{n-1} - \\frac{4}{3}\\phi_{n-2}+\\frac{1}{3}\\phi_{n-3}\\right]+\\frac{1}{3}\\frac{3}{2h}\\left[\\phi_{n-2} - \\frac{4}{3}\\phi_{n-3}+\\frac{1}{3}\\phi_{n-4}\\right] \\] \\[ \\frac{2h}{3C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{3}{2h}\\phi_n - \\frac{2}{h}\\phi_{n-1}-\\frac{2}{h}\\phi_{n-1}+\\frac{1}{2h}\\phi_{n-2} + \\frac{8}{3h}\\phi_{n-2}+\\frac{1}{2h}\\phi_{n-2}-\\frac{2}{3h}\\phi_{n-3} - \\frac{2}{3h}\\phi_{n-3}+\\frac{1}{6h}\\phi_{n-4} \\] \\[ \\frac{2h}{3C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{3}{2h}\\phi_n - \\frac{4}{h}\\phi_{n-1} + \\frac{22}{6h}\\phi_{n-2}-\\frac{4}{3h}\\phi_{n-3}+\\frac{1}{6h}\\phi_{n-4} \\] \\[ \\phi_n - \\frac{4h^{2}}{9C_{1}}\\frac{2\\pi}{\\Phi_{0}}I_{C1} = \\frac{8}{3}\\phi_{n-1} - \\frac{22}{9}\\phi_{n-2}+\\frac{8}{9}\\phi_{n-3}-\\frac{1}{9}\\phi_{n-4} \\] This can then be reduced to a component stamp as follows: \\[ \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{4h^{2}}{9C_{1}}\\frac{2\\pi}{\\Phi_{0}} \\end{bmatrix} \\begin{bmatrix} \\phi^{+} \\\\ \\phi^{-} \\\\ I_{C_{1}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{8}{3}\\phi_{n-1} - \\frac{22}{9}\\phi_{n-2}+\\frac{8}{9}\\phi_{n-3}-\\frac{1}{9}\\phi_{n-4} \\end{bmatrix} \\] With this expansion it is shown, the capacitor requires up to 4 previous time step values to compute the current step. JoSIM has been adapted to allow phase analysis on any design that works with voltage analysis without requiring alterations to the netlist file. Since the voltage is simply the scaled time derivative of the phase the voltage can be calculated as a post process if the user requests it. As noted in the CLI Options section, the default mode for simulation is now phase as of version 2.5. All the MNPA stamps are included in the Component Stamps section.","title":"Modified nodal phase analysis"},{"location":"tech_disc/#mutual-inductances","text":"If there are any mutual inductances in the circuit then this section is triggered. When found in the previous section the mutual inductances are simply added to a list for later processing. This is done to allow all inductors to be created as objects first before the mutual inductors are applied. This also allows us to perform a sanity check, ensuring that the inductors being coupled exist.","title":"Mutual Inductances"},{"location":"tech_disc/#create-csr","text":"The concept of zero is a strange thing, to humans it is nothing but to machines it is the same as all other numbers and takes up just as much memory. Since we do not want to waste memory and computation storing the number zero we use a different form of matrix representation known as the compressed row storage (CSR) 7 . This data structure consists of 3 vectors, namely the non-zero (nnz), the column indices (ci) and the row pointer (rp) vectors. The non-zero vector only stores the non-zero elements of each component. The column indices vector stores the index where each of the non-zeros are found. The row pointer stores the total number of non-zeros after each row, starting with zero. This allows the simulation engine to quickly discern which non-zero belongs in which position if the matrix were actually a full sparse matrix. As example to demonstrate this we use the following 5x5 matrix: \\[ \\begin{bmatrix} 1 & 0 & 0 & 4 & 0\\\\ 0 & 3 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0\\\\ 0& 4 & 0 & 5 & 0 \\\\ 0 & 0 & 0 & 0 & 1 \\end{bmatrix} \\] Storing this matrix in system memory would take up 25 numbers. If we were to convert this to CSR format we arrive at the following 3 vectors: \\[ nnz=\\left[1, 4, 3, 1, 4, 5, 1\\right] \\] \\[ ci=\\left[0,3,1,2,1,3,4\\right] \\] \\[ rp=\\left[0,2,3,4,6,7\\right] \\] This data structure only takes up 20 numbers to store. This does not seem much less than the 25 before, but this scales very significantly when working with very large circuits. During the matrix creation part, the objects created already form these nnz, ci and rp vectors for each component. During this part all these vectors are simply collected to form the overall CSR for the circuit.","title":"Create CSR"},{"location":"tech_disc/#find-relevant-traces","text":"Like before with the CSR instead of storing the full matrix to save memory, it would also be advantageous to not store every value computed during the simulation step for every component. To avoid this, we identify the specific traces (reference to relevant computed values) before simulation starts. This is done by combing the controls list for any output statements ( .print , .plot or .save ) and identifying which component or node each refer to. The relevant node and current branch indices are then stored in a list which will be used during simulation.","title":"Find Relevant Traces"},{"location":"tech_disc/#simulation","text":"Once we have a all the component objects and a CSR representing the matrix we can perform the requested simulation. An overview of the simulation step is shown below.","title":"Simulation"},{"location":"tech_disc/#create-simulation-objects","text":"JoSIM uses the sparse matrix solver library SuiteSparse 8 of which the KLU solver is implemented. To use KLU specific objects need to be created using the CSR vectors. During this part these objects are created and initialized using the relevant data.","title":"Create Simulation Objects"},{"location":"tech_disc/#start-simulation","text":"A transient simulation is synonymous to a time domain simulation, and since we are working with a digital system this time simulation needs to be discretized into a set amount of steps determined by the total simulation time divided by the step size.","title":"Start Simulation"},{"location":"tech_disc/#create-b-matrix","text":"The b matrix is created using the known values from each component's RHS of the equation. All components are itterated through and their RHS values inserted into the b matrix at the correct locations before simulation is done.","title":"Create b Matrix"},{"location":"tech_disc/#solve-axb","text":"With both A and b known, KLU solves x (the unknowns) for the current step.","title":"Solve Ax=b"},{"location":"tech_disc/#store-results","text":"The results in x are iterated, storing only the relevant trace data as previously determined. The implementation of a transmission line in JoSIM is only a scaled time delay at present and as such the currents of and nodes connected to all transmission lines need to be stored for all time. Once completed, the process is repeated for the next time step until the simulation is finished.","title":"Store results"},{"location":"tech_disc/#output-results","text":"The results from the simulation along with the time data is formatted to form a 2D data set with a label describing each column of data. JoSIM supports exactly 3 output formats. Each of which are determined by the extension of the file specified in the CLI Options . These formats are comma separated value (CSV), space separated value (DAT) and raw SPICE output.","title":"Output Results"},{"location":"tech_disc/#csv-csv","text":"The formatted results are stored in a file with the labels at the top followed by each row of data starting with the time point. All elements in this file are comma separated. This makes it very easy to read and understand from a human perspective but as well by many software libraries for plotting. This is also the default format in the case that output was requested but no file name provided. In this case the results will be stored in a file called output.csv .","title":"CSV (.csv)"},{"location":"tech_disc/#dat-dat","text":"Very similar to the CSV file but instead of commas, spaces are used. This is a legacy format used as output by older simulators such as JSIM.","title":"DAT (.dat)"},{"location":"tech_disc/#raw-no-extension","text":"If no extension is given for the file name then a RAW SPICE file will be created. This is a very specifically formatted file that specifies the variables in a list, followed by a time step and each variable's data for that time point. This format is understood by many SPICE output plotting tools.","title":"RAW (no extension)"},{"location":"tech_disc/#plotting-interfaces","text":"In previous versions of JoSIM there existed 2 plotting windows, namely FLTK and Matplotlib. These interfaces were, however, ultimately scrapped due to maintainability issues as well as cross-platform compatibility. The user is requested to use the plotting system they are most comfortable with. Below we provide a simple Python 3 script that plots all the results in a .csv file. It is very basic and the user should modify it as required. This script requires installation of the Numpy as well as Matplotlib packages for Python 3. Optionally, we comment the lines for use of the Qt5 backend for plotting. The user can enable this if the PyQt5 package is installed. A Plotly and Pandas script is provided in the scripts folder of the GitHub repository that visualizes the results in a much more elegant way, with many more settings that can be adjusted by the user. #!/usr/bin/env python import math # import matplotlib # matplotlib.use('Qt5Agg') import matplotlib.pyplot as pl from matplotlib import gridspec import numpy as np import csv import sys time = [] data = [] labels = set () with open ( sys . argv [ 1 ], 'r' ) as csvFile : reader = csv . DictReader ( csvFile ) labels = reader . fieldnames data . append ([]) for row in reader : time . append ( float ( row [ labels [ 0 ]])) for var in range ( 1 , len ( labels )): data . append ([]) data [ var ] . append ( float ( row [ labels [ var ]])) csvFile . close () N = len ( labels ) - 1 cols = int ( math . ceil ( N / 4 )) rows = int ( math . ceil ( N / cols )) gs = gridspec . GridSpec ( rows , cols ) fig = pl . figure () for var in range ( 1 , len ( labels )): ax = fig . add_subplot ( gs [ var - 1 ]) ax . plot ( time , data [ var ]) ax . set_xlabel ( labels [ 0 ]) ax . set_ylabel ( labels [ var ]) fig . set_tight_layout ( True ) fig . show () input () E. W. Dijkstra, \"Algol 60 translation : An Algol 60 translator for the x1 and Making a translator for Algol 60\" in MR35, Mathematisch Centrum, Amsterdam , 1961 \u21a9 J. Satchell, \"Limitations on HTS single flux quantum logic,\" in IEEE Transactions on Applied Superconductivity , vol. 9, no. 2, pp. 3841-3844, June 1999, doi: 10.1109/77.783865 \u21a9 L. Nagel, \"Spice: A computer program to simulate computer circuits\" in University of California, Berkeley UCB/ERL Memo M520 , pp. 201-204, 1995 \u21a9 C. Ho, A. Ruehli, & P. Brennan, \"The modified nodal approach to network analysis\" in IEEE Transactions on circuits and systems , vol. 22, no. 6, pp. 506-509, 1975 \u21a9 C. F. Curtiss, & J. O. Hirschfelder, \"Integration of stiff equations\" in Proceedings of the National Academy of Sciences , vol. 38, no. 3, pp. 235-243, 1952 \u21a9 T. P. Orlando & K. A. Delin, \"Foundations of Applied Superconductivity\", Addison-Wesley Reading, MA vol. 8, 1991 \u21a9 A. Bulu, J. T. Fineman, M. Frigo, J. R. Gilbert and C. E. Leiserson, \"Parallel sparse matrix-vector and matrix-transpose-vector multiplication using compressed sparse blocks\" in Proceedings of the twenty-first annual symposium on Parallelism in algorithms and architectures , pp. 233-244, 2009 \u21a9 T. A. Davis, \"Direct methods for sparse linear systems\", SIAM, Philadelphia, 2006 \u21a9","title":"Plotting interfaces"}]}