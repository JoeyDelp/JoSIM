{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JoSIM - Superconducting Circuit Simulator Developers Manual v2.4 Project Status Testing: v2.5 - Status: Stable: v2.4.1 - Status: Introduction JoSIM was developed under IARPA contract SuperTools(via the U.S. Army Research Office grant W911NF-17-1-0120). JoSIM is a analogue circuit simulator with SPICE syntax input that has inherent support for the superconducting Josephson junction element. JoSIM is meant to function as a replacement to the aging simulators such as JSIM[ jsim ] and WRspice[ wrspice ]. JoSIM is written in modern C++ and is fully customizable and extendable to offer support for improved superconducting elements as well better approximations to the Josephson effect in superconducting materials. A .cir file containing a SPICE syntax circuit netlist is provided as input. The circuit netlist, given appropriate input excitations can then be simulated through transient analysis. Results of this simulation can be dumped to standard output or saved in various formats such as a comma separated value ( .csv ) file. Fig. 1 shows an overview of how JoSIM operates internally. This is much like any other SPICE deck simulator with the exception that it incorporates native handling of the Josephson junction. We will discuss each of these blocks in further detail in the Technical Discussion section. Fig. 1 - JoSIM Macro Overview. Project layout The JoSIM repository has the following layout. A quick description shows the purpose of the various files and folders. cmake # CMake scripts. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. include/ JoSIM # JoSIM header files. lib # Libraries for different platforms. scripts # Some Python3 scripts to automate testing and plotting site # Where this documentation spawns from. src/ josim_vs # Visual Studio solution for JoSIM. ... # JoSIM source files. test # Folder containing various examples. README.md # Basic readme to get the user going. LICENSE # License that governs use of JoSIM. CMakeLists.txt # Configuration to compile code. ... # Other configuration files and scripts. Initial setup Release versions of JoSIM can be found on the release page of the open source github repository repository. At the time of writing this version is 2.4. The source can also be cloned and compiled for either macOS, Linux or Windows. Within this repository there will be a CMakeLists.txt which is a recipe used to compile JoSIM using CMake. To compile the source a working C++ compiler with support for C++17 is required. Additionally SuiteSparse linear algebra libraries are required but are provided in the repository. Git version control software is recommended, but is not required to compile JoSIM. A single executable binary is generated using the CMake recipe and can be placed anywhere on the system as well as freely redistributed. License JoSIM is governed by the MIT license, which is a very permissive license that allows anyone to redistribute the source as well as commercialize it without repercussions. The MIT license allows use of this software within proprietary software as long as all copies of the licensed software includes a copy of the MIT license as well as the copyright notice. Building from source Linux These instructions were executed on a minimal install of CentOS 7 to reduce oversight in the compilation instructions created by previous package installs. For other distributions please use the package manager relevant to the distribution of choice. A working internet connection is required, as well as the ability to install packages. If the internet connection is not up please run, and replace with your relevant interface i.e eth0 : $ sudo ifup <network interface> CentOS 7 does not contain all the enterprise Linux packages in its default repository and therefore needs to be activated using: $ sudo yum install epel-release $ sudo yum update CentOS 7 will require development packages to be installed. Fortunately this can be done using a single command: $ sudo yum groupinstall \"Development Tools\" This will install various development tools such as gcc , make and git . JoSIM, however, requires a newer version of gcc than the one supplied within these packages. Fortunately this can be installed fairly easily by running the following: $ sudo yum install centos-release-scl $ sudo yum install devtoolset-8 $ scl enable devtoolset-8 bash The last command needs to be entered whenever the newer gcc is needed. This can fortunately be shortened using an alias: $ echo 'alias dts8=\"scl enable devtoolset-8 bash\"' >> ~/.bashrc This will enable the devtoolset-8 environment on the current bash by just entering the command dts8 . To simplify installation of various packages we make use of Python 3 and pip: $ sudo install python36 python36-pip This allows installation of the most relevant package version of cmake : $ pip3 install cmake --user As of version 2.4 the relevant SuiteSparse dependency code is compiled into JoSIM resulting in no additional dependencies being needed. We are now ready to compile JoSIM JoSIM source can be directly downloaded from the repository as a compressed .tar.gz file or by cloning the repository. In either case, navigate to a directory where compilation will take place and extract the tarball or execute: $ git clone https://github.com/JoeyDelp/JoSIM.git $ cd JoSIM Navigate to the newly cloned/extracted JoSIM directory then run the following commands: $ mkdir build $ cd build $ cmake .. $ cmake --build . --config Release This will generate a JoSIM executable in the build directory. Additionally, the libjosim library will also be generated. To use the library (and josim-cli) they need to be PATH obtainable. The best way to do this is to do: $ sudo make install Apple macOS Apple macOS is very similar to most Unix systems and therefore follows mostly the same procedure. The user would clone the repository and install CMake as well as the necessary library as indicated in previous sections. These requirements can be installed using either Homebrew, Macports or compiled from source using the standard macOS compilers (installed through Xcode). Python 3 is available through Homebrew and CMake can almost always be installed using pip (PyPI). Microsoft Windows There are various ways to compile JoSIM on the Microsoft Windows platform. The simplest way to do this is to install the Community version of Microsoft Visual Studio , which is free to use. This is only to acquire a working C++ compiler that can be used by CMake. Next Python 3 will also be needed. This can be installed using Windows Store, Anaconda or Miniconda . Once installed CMake can be installed much the same as any other system: $ pip install cmake --user To ensure that CMake detects the correct compiler (a restart might be required after MSVC install) simply run: $ cmake --help This should produce a help menu with a generator list at the bottom. If MSVC is installed and detected then it should have an asterisk (*) next to the relevant MSVC version to indicate that it is the default generator. The rest of the guide follows the same steps as Linux: $ mkdir build $ cd build $ cmake .. $ cmake --build . --config Release This will produce the JoSIM executable and library in the build/Release folder. .center { display: block; margin: 0 auto; } jsim Fang E.S.: A Josephson integrated circuit simulator (JSIM) for superconductive electronics application . (1989) wrspice Simulator W.C.: Whiteley Research Incorporated . (2017)","title":"Home"},{"location":"#josim-superconducting-circuit-simulator","text":"Developers Manual v2.4","title":"JoSIM - Superconducting Circuit Simulator"},{"location":"#project-status","text":"","title":"Project Status"},{"location":"#testing-v25-status","text":"","title":"Testing: v2.5 - Status:"},{"location":"#stable-v241-status","text":"","title":"Stable: v2.4.1 - Status:"},{"location":"#introduction","text":"JoSIM was developed under IARPA contract SuperTools(via the U.S. Army Research Office grant W911NF-17-1-0120). JoSIM is a analogue circuit simulator with SPICE syntax input that has inherent support for the superconducting Josephson junction element. JoSIM is meant to function as a replacement to the aging simulators such as JSIM[ jsim ] and WRspice[ wrspice ]. JoSIM is written in modern C++ and is fully customizable and extendable to offer support for improved superconducting elements as well better approximations to the Josephson effect in superconducting materials. A .cir file containing a SPICE syntax circuit netlist is provided as input. The circuit netlist, given appropriate input excitations can then be simulated through transient analysis. Results of this simulation can be dumped to standard output or saved in various formats such as a comma separated value ( .csv ) file. Fig. 1 shows an overview of how JoSIM operates internally. This is much like any other SPICE deck simulator with the exception that it incorporates native handling of the Josephson junction. We will discuss each of these blocks in further detail in the Technical Discussion section. Fig. 1 - JoSIM Macro Overview.","title":"Introduction"},{"location":"#project-layout","text":"The JoSIM repository has the following layout. A quick description shows the purpose of the various files and folders. cmake # CMake scripts. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. include/ JoSIM # JoSIM header files. lib # Libraries for different platforms. scripts # Some Python3 scripts to automate testing and plotting site # Where this documentation spawns from. src/ josim_vs # Visual Studio solution for JoSIM. ... # JoSIM source files. test # Folder containing various examples. README.md # Basic readme to get the user going. LICENSE # License that governs use of JoSIM. CMakeLists.txt # Configuration to compile code. ... # Other configuration files and scripts.","title":"Project layout"},{"location":"#initial-setup","text":"Release versions of JoSIM can be found on the release page of the open source github repository repository. At the time of writing this version is 2.4. The source can also be cloned and compiled for either macOS, Linux or Windows. Within this repository there will be a CMakeLists.txt which is a recipe used to compile JoSIM using CMake. To compile the source a working C++ compiler with support for C++17 is required. Additionally SuiteSparse linear algebra libraries are required but are provided in the repository. Git version control software is recommended, but is not required to compile JoSIM. A single executable binary is generated using the CMake recipe and can be placed anywhere on the system as well as freely redistributed.","title":"Initial setup"},{"location":"#license","text":"JoSIM is governed by the MIT license, which is a very permissive license that allows anyone to redistribute the source as well as commercialize it without repercussions. The MIT license allows use of this software within proprietary software as long as all copies of the licensed software includes a copy of the MIT license as well as the copyright notice.","title":"License"},{"location":"#building-from-source","text":"","title":"Building from source"},{"location":"#linux","text":"These instructions were executed on a minimal install of CentOS 7 to reduce oversight in the compilation instructions created by previous package installs. For other distributions please use the package manager relevant to the distribution of choice. A working internet connection is required, as well as the ability to install packages. If the internet connection is not up please run, and replace with your relevant interface i.e eth0 : $ sudo ifup <network interface> CentOS 7 does not contain all the enterprise Linux packages in its default repository and therefore needs to be activated using: $ sudo yum install epel-release $ sudo yum update CentOS 7 will require development packages to be installed. Fortunately this can be done using a single command: $ sudo yum groupinstall \"Development Tools\" This will install various development tools such as gcc , make and git . JoSIM, however, requires a newer version of gcc than the one supplied within these packages. Fortunately this can be installed fairly easily by running the following: $ sudo yum install centos-release-scl $ sudo yum install devtoolset-8 $ scl enable devtoolset-8 bash The last command needs to be entered whenever the newer gcc is needed. This can fortunately be shortened using an alias: $ echo 'alias dts8=\"scl enable devtoolset-8 bash\"' >> ~/.bashrc This will enable the devtoolset-8 environment on the current bash by just entering the command dts8 . To simplify installation of various packages we make use of Python 3 and pip: $ sudo install python36 python36-pip This allows installation of the most relevant package version of cmake : $ pip3 install cmake --user As of version 2.4 the relevant SuiteSparse dependency code is compiled into JoSIM resulting in no additional dependencies being needed. We are now ready to compile JoSIM JoSIM source can be directly downloaded from the repository as a compressed .tar.gz file or by cloning the repository. In either case, navigate to a directory where compilation will take place and extract the tarball or execute: $ git clone https://github.com/JoeyDelp/JoSIM.git $ cd JoSIM Navigate to the newly cloned/extracted JoSIM directory then run the following commands: $ mkdir build $ cd build $ cmake .. $ cmake --build . --config Release This will generate a JoSIM executable in the build directory. Additionally, the libjosim library will also be generated. To use the library (and josim-cli) they need to be PATH obtainable. The best way to do this is to do: $ sudo make install","title":"Linux"},{"location":"#apple-macos","text":"Apple macOS is very similar to most Unix systems and therefore follows mostly the same procedure. The user would clone the repository and install CMake as well as the necessary library as indicated in previous sections. These requirements can be installed using either Homebrew, Macports or compiled from source using the standard macOS compilers (installed through Xcode). Python 3 is available through Homebrew and CMake can almost always be installed using pip (PyPI).","title":"Apple macOS"},{"location":"#microsoft-windows","text":"There are various ways to compile JoSIM on the Microsoft Windows platform. The simplest way to do this is to install the Community version of Microsoft Visual Studio , which is free to use. This is only to acquire a working C++ compiler that can be used by CMake. Next Python 3 will also be needed. This can be installed using Windows Store, Anaconda or Miniconda . Once installed CMake can be installed much the same as any other system: $ pip install cmake --user To ensure that CMake detects the correct compiler (a restart might be required after MSVC install) simply run: $ cmake --help This should produce a help menu with a generator list at the bottom. If MSVC is installed and detected then it should have an asterisk (*) next to the relevant MSVC version to indicate that it is the default generator. The rest of the guide follows the same steps as Linux: $ mkdir build $ cd build $ cmake .. $ cmake --build . --config Release This will produce the JoSIM executable and library in the build/Release folder. .center { display: block; margin: 0 auto; } jsim Fang E.S.: A Josephson integrated circuit simulator (JSIM) for superconductive electronics application . (1989) wrspice Simulator W.C.: Whiteley Research Incorporated . (2017)","title":"Microsoft Windows"},{"location":"bugs/","text":"Development schedule and bug reporting JoSIM is an open-source project and thus relies heavily on feedback from the community. The development team consists at present of only a single person and therefore handling multiple tasks can sometimes be an issue. We do, however, request from the community to be our testers and to report any bugs that might pop out from time to time. We will do our best to catch these bugs and fix any holes in the next release. JoSIM will from this release (v2.4) adopt a more rolling release like schedule where additional features and bug fixes will be released incrementally through incremental versions to try and avoid large scale problems with long lasting side effects. Major releases will be made available on the releases page and will be reported, whereas minor releases will not be reported. Please report any bugs through creating a new issue on the Issues page.","title":"Development Schedule and Bugs"},{"location":"bugs/#development-schedule-and-bug-reporting","text":"JoSIM is an open-source project and thus relies heavily on feedback from the community. The development team consists at present of only a single person and therefore handling multiple tasks can sometimes be an issue. We do, however, request from the community to be our testers and to report any bugs that might pop out from time to time. We will do our best to catch these bugs and fix any holes in the next release. JoSIM will from this release (v2.4) adopt a more rolling release like schedule where additional features and bug fixes will be released incrementally through incremental versions to try and avoid large scale problems with long lasting side effects. Major releases will be made available on the releases page and will be reported, whereas minor releases will not be reported. Please report any bugs through creating a new issue on the Issues page.","title":"Development schedule and bug reporting"},{"location":"comp_stamps/","text":"Component Stamps In this section we will explore each of the available component stamps found in JoSIM. This will serve as insight into how trapezoidal integration is performed to produce a time dependent voltage or phase equation for each of these components. This will serve as a continuation of what was shown in the Technical Discussion section for the Inductor. Resistor Fig. 1 - A basic resistor with current flowing through it A resistor is a passive circuit element for which the voltage dependent equation is defined through Ohm's law: v_{12}(t) = i_{R1}(t) R1 Written as: \\frac{v_{12}(t)}{R1} = i_{R1}(t) V_{12}-RI_{R} = 0 This can then be written as a matrix stamp in the form \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -R \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2}\\\\ I_{R} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation} If we expand this using the voltage-phase relation shown in Technical Discussion , then we can rewrite the equation as: \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi_{12}}{dt}\\frac{1}{R1} = I_{R1} This equation will now require the application of the trapezoidal method: \\frac{\\Phi_{0}}{2\\pi R1}\\frac{2}{h_n}(\\phi_n - \\phi_{n-1})-{I_{R1}}_{n-1} = {I_{R1}}_{n} This reduces to: \\frac{\\Phi_{0}}{\\pi R1 h_n}\\phi_n - {I_{R1}}_{n} = \\frac{\\Phi_{0}}{\\pi R1h_n}\\phi_{n-1}+{I_{R1}}_{n-1} \\phi_{n}-\\frac{\\pi R1h_n}{\\Phi_0}{I_{R1}}_{n}=\\phi_{n-1}+\\frac{\\pi R1h_n}{\\Phi_0}{I_{R1}}_{n-1} This allows us to create a phase resistor matrix stamp as: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & \\frac{\\pi R1h_n}{\\Phi_0} \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{R1} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\phi_{n-1}+\\frac{\\pi R1h_n}{\\Phi_0}{I_{R1}}_{n-1} \\end{bmatrix} \\end{equation} Capacitor Fig. 2 - A basic capacitor with current flowing through it A capacitor as shown in Figure 2 has a voltage dependent equation defined by: i_{C1}(t) =C1\\frac{v_{12}(t)}{dt} This is a first order differential and needs to be expanded using the trapezoidal rule: \\frac{2C1}{h_n}(V_n - V_{n-1})-{I_{C1}}_{n-1} = {I_{C1}}_{n} V_{n} - \\frac{h_n}{2C1}{I_{C1}}_{n} = V_{n-1} + \\frac{h_n}{2C1}{I_{C1}}_{n-1} This allows us to create the capacitor stamp as: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{h_n}{2C1} \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\\\ I_{L1} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ V_{n-1} + \\frac{h_n}{2C1}{I_{C1}}_{n-1} \\end{bmatrix} \\end{equation} If we wish to create a phase mode analysis stamp for the capacitor we need to replace the voltage with the voltage-phase relation. i_{C1} = C1\\frac{\\Phi_0}{2\\pi}\\frac{d^2\\phi}{dt} This second order differential needs to be expanded using the trapezoidal rule: {I_{C1}}_{n} = \\frac{C1\\Phi_0}{2\\pi}\\left[ \\frac{2}{h_n} \\left({\\frac{d\\phi}{dt}}_{n} - {\\frac{d\\phi}{dt}}_{n-1}\\right) - \\left(\\frac{d^2\\phi}{dt}\\right)_{n-1} \\right] {I_{C1}}_{n} = \\frac{C1\\Phi_0}{\\pi h_n} \\left({\\frac{d\\phi}{dt}}_{n} - {\\frac{d\\phi}{dt}}_{n-1}\\right) -{I_{C1}}_{n-1} {I_{C1}}_{n} = \\frac{2C1\\Phi_0}{\\pi h_n^2} {\\phi}_{n} - \\frac{2C1\\Phi_0}{\\pi h_n^2} {\\phi}_{n-1} - \\frac{2C1\\Phi_0}{\\pi h_n}{\\frac{d\\phi}{dt}}_{n-1} -{I_{C1}}_{n-1} \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n} - {\\phi}_{n} = -{\\phi}_{n-1} - h_n{\\frac{d\\phi}{dt}}_{n-1} - \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n-1} {\\phi}_{n} - \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n} = {\\phi}_{n-1} + h_n{\\frac{d\\phi}{dt}}_{n-1} + \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n-1} Which leads to the phase component stamp matrix: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{\\pi h_n^2}{2C1\\Phi_0} \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{C1} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ {\\phi}_{n-1} + h_n{\\frac{d\\phi}{dt}}_{n-1} + \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n-1} \\end{bmatrix} \\end{equation} Josephson Junction Fig. 3 - A basic Josephson junction with current flowing through it The Josephson junction shown in Figure 3 is based on the resistively and capacitivrely shunted junction (RCSJ) model. To determine the junction current, the summation of the currents through all three branches of the RCSJ is required. If we use the basic sinusoidal of the phase to represenent the junction branch, we formulate the total current as: I_{B1} = I_c \\sin{\\phi} + \\frac{V_{12}}{R} + C\\frac{dV_{12}}{dt} Which when expanded with the trapezoidal rule becomes: {I_{B1}}_{n} = I_c\\sin{\\phi_n} + \\frac{V_{n}}{R} + \\frac{2C}{h_n}(V_{n} - V_{n-1}) - C{\\frac{dV}{dt}}_{n-1} -\\frac{V_{n}}{R} - \\frac{2C}{h_{n}}V_{n} + I_{B1_{n}} = I_{c}\\sin{\\phi_{n}} - \\frac{2C}{h_n}V_{n-1}-C\\frac{dV}{dt}_{n-1} (\\frac{1}{R} + \\frac{2C}{h_n})V_n - {I_{B1}}_{n} = -I_c\\sin{\\phi_n} + \\frac{2C}{h_n}V_{n-1} + C{\\frac{dV}{dt}}_{n-1} V_{n} - \\frac{h_{n}R}{h_{n} + 2RC}I_{B1_{n}} = \\left(\\frac{h_{n}R}{h_{n} + 2RC}\\right)\\left(-I_{c}\\sin{\\phi_{n}} + \\frac{2C}{h_{n}}V_{n-1} + C\\frac{dV}{dt}_{n-1}\\right) This equation depends on the phase at the present time step, which needs to be solved. Phase is not, however, solved and we therefore need to use the voltage-phase relationship to find a voltage dependent solution for the phase: V_n = \\frac{\\hbar}{2e}{\\frac{d\\phi}{dt}}_{n} V_{n} = \\frac{2}{h_n}\\frac{\\hbar}{2e}(\\phi_n - \\phi_{n-1}) - V_{n-1} V_n - \\frac{\\hbar}{h_n e}\\phi_{n} = - \\frac{\\hbar}{h_n e}\\phi_{n-1} - V_{n-1} We can now combine these two equations to form the component stamp matrix: \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{\\hbar}{h_n e} & 0 \\\\ 1 & -1 & 0 & - \\frac{h_{n}R}{h_{n} + 2RC} \\end{bmatrix} \\begin{bmatrix} V_1 \\\\ V_2 \\\\ \\phi_{n}\\\\ I_{B1_{n}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -\\frac{\\hbar}{h_n e}\\phi_{n-1} - V_{n-1} \\\\ I_{s} \\end{bmatrix} \\end{equation} Where I_{s} = \\left(\\frac{h_{n}R}{h_{n} + 2RC}\\right)\\left(-I_{c}\\sin{\\phi_{n}} + \\frac{2C}{h_{n}}V_{n-1} + C\\frac{dV}{dt}_{n-1}\\right) It is, however, not possible to use the phase value for the current time step in the calculation of the current time step, we therefore have to rely on an estimated phase value based on previous values. We define this estimation as: \\phi_n^0=\\phi_{n-1}+\\frac{h_n e}{\\hbar}(V_{n-1} + v_n^0) v_n^0=V_{n-1}+h_n{\\frac{dV}{dt}}_{n-1} The current phase case is rather basic and we therefore replace this term with the more general term defined by Haberkorn[ haberkorn ]: I_s = \\frac{\\pi\\Delta}{2eR_N}\\frac{\\sin{\\phi}}{\\sqrt{1 - \\overline{D}\\sin^2\\left(\\frac{\\phi}{2}\\right)}}\\tanh\\left[\\frac{\\Delta}{2k_BT}\\sqrt{1-\\overline{D}\\sin^2\\left(\\frac{\\phi}{2}\\right)}\\right] This equation introduces temperature dependence within the junction model through \\Delta : \\Delta_0 = 1.76k_BT_c \\Delta = \\Delta_0\\sqrt{\\cos\\left[\\frac{\\pi}{2}\\left(\\frac{T}{T_c}\\right)^2\\right]} with T , the boiling point of liquid Helium (4.2K), T_c the critical temperature of Niobium (9.1K) and k_B is Boltzmann's constant for average kinetic energy of particles. The resistance value R_N is defined as: R_N = \\frac{\\pi\\Delta}{2eI_c}\\tanh\\left(\\frac{\\Delta}{2k_{B}T}\\right) This allows us to change the characteristics of the tunnel current by simply altering the transparency value \\overline{D} . For values of \\overline{D} \\ll 1 the equation becomes the normal sinusoidal equation whereas for large values of \\overline{D} it becomes the non-sinusoidal ballistic tunneling equation. To define the Josephson junction in phase we simply swap the voltage and phase of the component previously identified. The equations remain the same since the Josephson junction is already a phase element. \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{h_n e}{\\hbar} & 0 \\\\ 0 & 0 & 1 & - \\frac{h_{n}R}{h_{n} + 2RC} \\end{bmatrix} \\begin{bmatrix} \\phi_1 \\\\ \\phi_2 \\\\ V_{n}\\\\ I_{B1_{n}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\phi_{n-1} + \\frac{h_n e}{\\hbar}V_{n-1} \\\\ I_{s} \\end{bmatrix} \\end{equation} Voltage Source Fig. 4 - A basic voltage source A voltage source is nothing more than is implied. It is a source of voltage, this indicates that the voltage at any time step is known. We can therefore easily create a component stamp matrix in the form: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\\\ I_{V1} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ V1 \\end{bmatrix} \\end{equation} The phase version of this element simply sees the voltage replaced with the voltage-phase relation: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{V1} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\frac{\\Phi_0}{\\pi h_n}(V_n - V_{n-1}) + \\phi_{n-1} \\end{bmatrix} \\end{equation} Current Source Fig. 5 - A basic current source A current source is, as implied, a current that is known at every time step in the simulation. It can therefore simply be applied where needed on the RHS. \\begin{equation} \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\end{bmatrix} = \\begin{bmatrix} -I1\\\\ I1 \\end{bmatrix} \\end{equation} Phase Source Like a voltage source simply applies a phase where needed within the circuit. \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{\\phi} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\phi_n \\end{bmatrix} \\end{equation} Transmission Line Fig. 6 - A basic transmission line model A transmission line is, at present, simply a delay element where the delay T_D and impedence Z_0 define the length of the transmission line. At present we model the transmission line as an ideal element without any losses. We will in future implement a more accurate model of the transmission line. The equations that govern this lossless transmission line are: v_{12}(t)-Z_0i_1(t) = v_{34}(t-T_D)+Z_0\\centerdot i_2(t-T_D) v_{34}(t)-Z_0i_2(t) = v_{12}(t-T_D)+Z_0\\centerdot i_1(t-T_D) which leads to {V_{12}}_{n}-Z_0{I_1}_{n}={V_{34}}_{n-k}+Z_0{I_2}_{n-k} {V_{34}}_{n}-Z_0{I_2}_{n}={V_{12}}_{n-k}+Z_0{I_1}_{n-k} where k=\\frac{T_D}{h_n} Which allows us to create a component stamp matrix \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -Z_0 & 0 \\\\ 0 & 0 & 1 & -1 & 0 & -Z_0 \\end{bmatrix} \\begin{bmatrix} V_{12} \\\\ V_{21} \\\\ V_{34} \\\\ V_{43} \\\\ I_{1} \\\\ I_{2} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ 0 \\\\ 0 \\\\ {V_{34}}_{n-k}+Z_0{I_2}_{n-k} \\\\ {V_{12}}_{n-k}+Z_0{I_1}_{n-k} \\end{bmatrix} \\end{equation} The phase equations for the transmission line are: \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{12}}{dt}}_{n} - Z_0 {I_{1}}_{n} = \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{34}}{dt}}_{n-k} + Z_0 {I_{2}}_{n-k} \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{34}}{dt}}_{n} - Z_0 {I_{2}}_{n} = \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{12}}{dt}}_{n-k} + Z_0 {I_{1}}_{n-k} Since the equations are reciprocal, we only work with one side to simplify the rest of the equations. We rewrite this equation in terms of the differential as follows: \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{12}}{dt}}_{n} = Z_0 {I_{1}}_{n} + \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{34}}{dt}}_{n-k} + Z_0 {I_{2}}_{n-k} We now expand this using the trapezoidal method as: \\frac{\\Phi_0}{2\\pi}\\frac{2}{h_{n}}\\left(\\phi_{12_{n}} - \\phi_{12_{n-1}}\\right) - \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{12}}{dt}_{n-1} = Z_{0}I_{1_{n}}\\\\ + \\frac{\\Phi_0}{2\\pi}\\left(\\phi_{34_{n-k}} - \\phi_{34_{n-k-1}}\\right) - \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{34}}{dt}_{n-k-1} + Z_{0}I_{2_{n-k}} and substitute the unexpanded equation into the derivative: \\frac{\\Phi_0}{2\\pi}\\frac{2}{h_{n}}\\left(\\phi_{12_{n}} - \\phi_{12_{n-1}}\\right) - Z_0 {I_{1}}_{n-1} + \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{34}}{dt}}_{n-k-1} + Z_0 {I_{2}}_{n-k-1} = Z_{0}I_{1_{n}}\\\\ + \\frac{\\Phi_0}{2\\pi}\\left(\\phi_{34_{n-k}} - \\phi_{34_{n-k-1}}\\right) - \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{34}}{dt}_{n-k-1} + Z_{0}I_{2_{n-k}} Simplifying this equation results in: \\phi_{12_{n}} - \\frac{2\\pi h_{n}Z_{0}}{2\\Phi_{0}}I_{1_{n}} = \\frac{2\\pi h_{n}Z_{0}}{2\\Phi_{0}}\\left(I_{1_{n-1}} + I_{2_{n-k}} - I_{2_{n-k-1}}\\right) + \\phi_{12_{n-1}} +\\phi_{34_{n-k}} - \\phi_{34_{n-k-1}} With the reciprocal: {\\phi_{34}}_{n} - \\frac{2\\pi h_n Z_0}{\\Phi_0}{2I_{2}}_{n} = \\frac{2\\pi h_n Z_0}{2\\Phi_0}\\left(I_{2_{n-1}} + I_{1_{n-k}} - I_{1_{n-k-1}}\\right) + {\\phi_{34}}_{n-1} +\\phi_{12_{n-k}} - \\phi_{12_{n-k-1}} This leads to the component stamp matrix: \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & - \\frac{2\\pi h_n Z_0}{2 \\Phi_0} & 0 \\\\ 0 & 0 & 1 & -1 & 0 & - \\frac{2\\pi h_n Z_0}{2\\Phi_0} \\end{bmatrix} \\begin{bmatrix} \\phi_{12} \\\\ \\phi_{21} \\\\ \\phi_{34} \\\\ \\phi_{43} \\\\ I_{1} \\\\ I_{2} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ 0 \\\\ 0 \\\\ V_{T1} \\\\ V_{T2} \\end{bmatrix} \\end{equation} With V_{T1} and V_{T2} the RHS of the expanded equations above. Mutual inductance Fig. 7 - Mutual inductance model Mutual inductance allows simulation of coupling between inductors. This coupling adds an additional term to the inductor equation: v_{L1}(t) = L1 \\frac{di_{1}(t)}{dt} + M\\frac{di_2(t)}{dt} v_{L2}(t) = L2 \\frac{di_{2}(t)}{dt} + M\\frac{di_1(t)}{dt} with M = k\\sqrt{L_1 L_2} We expand these equations to: {V_{L1}}_{n} - \\frac{2L_1}{h_n}{I_{1}}_{n} - \\frac{2M}{h_n}{I_2}_{n} = - \\frac{2L_1}{h_n}{I_{1}}_{n-1} - \\frac{2M}{h_n}{I_2}_{n-1} - {V_{L1}}_{n-1} {V_{L2}}_{n} - \\frac{2L_2}{h_n}{I_{2}}_{n} - \\frac{2M}{h_n}{I_1}_{n} = - \\frac{2L_2}{h_n}{I_{2}}_{n-1} - \\frac{2M}{h_n}{I_1}_{n-1} - {V_{L2}}_{n-1} This leads to the component stamp matrix: \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -\\frac{2L_1}{h_n} & -\\frac{2M}{h_n} \\\\ 0 & 0 & 1 & -1 & -\\frac{2M}{h_n} & -\\frac{2L_2}{h_n} \\\\ \\end{bmatrix} \\begin{bmatrix} V_{L1} \\\\ -V_{L1} \\\\ V_{L2} \\\\ -V_{L2} \\\\ I_{L1} \\\\ I_{L2} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\0 \\\\ 0 \\\\ \\frac{2L_1}{h_n}{I_{1}}_{n-1} - \\frac{2M}{h_n}{I_2}_{n-1} - {V_{L1}}_{n-1} \\\\ - \\frac{2L_2}{h_n}{I_{2}}_{n-1} - \\frac{2M}{h_n}{I_1}_{n-1} - {V_{L2}}_{n-1} \\end{bmatrix} \\end{equation} The phase variant of this \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_1}{dt} = L_1\\frac{di_1}{dt} + M\\frac{di_2}{dt} \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_2}{dt} =M\\frac{di_1}{dt} + L_2\\frac{di_2}{dt} With integration on both sides \\frac{\\Phi_0}{2\\pi}\\phi_1 = L_1I_1 + MI_2 \\frac{\\Phi_0}{2\\pi}\\phi_2 = MI_1 + L_2I_2 This leads to a quite simplified component stamp matrix \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -\\frac{2\\pi}{\\Phi_0}L_1 & -\\frac{2\\pi}{\\Phi_0}M \\\\ 0 & 0 & 1 & -1 & -\\frac{2\\pi}{\\Phi_0}M & -\\frac{2\\pi}{\\Phi_0}L_2 \\\\ \\end{bmatrix} \\begin{bmatrix} \\phi_{L1} \\\\ -\\phi_{L1} \\\\ \\phi_{L2} \\\\ -\\phi_{L2} \\\\ I_{L1} \\\\ I_{L2} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\0 \\\\ 0 \\\\0 \\\\ 0 \\end{bmatrix} \\end{equation} Current Controlled Current Source Fig. 8 - Current controlled current source model Current controlled current source allows modulation of current in a particular branch through the current in a remote branch. I_{out} = \\beta I_{in} V_{1} - V_{2} = 0 \\beta = value \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & \\frac{1}{\\beta} \\\\ 0 & 0 & 0 & 0 & -\\frac{1}{\\beta} \\\\ 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{out} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation} Current Controlled Voltage Source Fig. 9 - Current controlled voltage source model Current controlled voltage source allows the modulation of a voltage node through a remote current source. V_{1} - V_{2} = 0 V_{3} - V_{4} = \\mu I_{in} \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 0 & -1 & 0\\ 0 & 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & 0 & -1\\\\ 0 & 0 & 1 & -1 & -\\mu & 0\\\\ 1 & -1 & 0 & 0 & 0 & -\\mu \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V{3}\\\\ V{4}\\\\ I_{in}\\\\ I_{out}\\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation} Voltage Controlled Current Source Fig. 10 - Voltage controlled current source model Voltage controlled current source allows the modulation of a current in a branch through a remote voltage source. \\alpha(V_{1} - V_{2}) = I_{out} \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & -1\\\\ 1 & -1 & 0 & 0 & -\\frac{1}{\\alpha} \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V{3}\\\\ V{4}\\\\ I_{in} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation} Voltage Controlled Voltage Source Fig. 11 - Voltage controlled voltage source model Voltage controlled current source allows the modulation of a current in a branch through a remote voltage source. A(V_{1} - V_{2}) = V_{3}-V_{4} \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & -1\\\\ G & -G & 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V{3}\\\\ V{4}\\\\ I_{out} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation} This concludes the section on component stamps and we move on to the Syntax Guide .center { display: block; margin: 0 auto; } haberkorn Haberkorn W., Knauer H., Richter J.: A theoretical study of the current-phase relation in Josephson contacts . physica status solidi (a). 47 , (1978)","title":"Component Stamps"},{"location":"comp_stamps/#component-stamps","text":"In this section we will explore each of the available component stamps found in JoSIM. This will serve as insight into how trapezoidal integration is performed to produce a time dependent voltage or phase equation for each of these components. This will serve as a continuation of what was shown in the Technical Discussion section for the Inductor.","title":"Component Stamps"},{"location":"comp_stamps/#resistor","text":"Fig. 1 - A basic resistor with current flowing through it A resistor is a passive circuit element for which the voltage dependent equation is defined through Ohm's law: v_{12}(t) = i_{R1}(t) R1 Written as: \\frac{v_{12}(t)}{R1} = i_{R1}(t) V_{12}-RI_{R} = 0 This can then be written as a matrix stamp in the form \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -R \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2}\\\\ I_{R} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation} If we expand this using the voltage-phase relation shown in Technical Discussion , then we can rewrite the equation as: \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi_{12}}{dt}\\frac{1}{R1} = I_{R1} This equation will now require the application of the trapezoidal method: \\frac{\\Phi_{0}}{2\\pi R1}\\frac{2}{h_n}(\\phi_n - \\phi_{n-1})-{I_{R1}}_{n-1} = {I_{R1}}_{n} This reduces to: \\frac{\\Phi_{0}}{\\pi R1 h_n}\\phi_n - {I_{R1}}_{n} = \\frac{\\Phi_{0}}{\\pi R1h_n}\\phi_{n-1}+{I_{R1}}_{n-1} \\phi_{n}-\\frac{\\pi R1h_n}{\\Phi_0}{I_{R1}}_{n}=\\phi_{n-1}+\\frac{\\pi R1h_n}{\\Phi_0}{I_{R1}}_{n-1} This allows us to create a phase resistor matrix stamp as: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & \\frac{\\pi R1h_n}{\\Phi_0} \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{R1} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\phi_{n-1}+\\frac{\\pi R1h_n}{\\Phi_0}{I_{R1}}_{n-1} \\end{bmatrix} \\end{equation}","title":"Resistor"},{"location":"comp_stamps/#capacitor","text":"Fig. 2 - A basic capacitor with current flowing through it A capacitor as shown in Figure 2 has a voltage dependent equation defined by: i_{C1}(t) =C1\\frac{v_{12}(t)}{dt} This is a first order differential and needs to be expanded using the trapezoidal rule: \\frac{2C1}{h_n}(V_n - V_{n-1})-{I_{C1}}_{n-1} = {I_{C1}}_{n} V_{n} - \\frac{h_n}{2C1}{I_{C1}}_{n} = V_{n-1} + \\frac{h_n}{2C1}{I_{C1}}_{n-1} This allows us to create the capacitor stamp as: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & -\\frac{h_n}{2C1} \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\\\ I_{L1} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ V_{n-1} + \\frac{h_n}{2C1}{I_{C1}}_{n-1} \\end{bmatrix} \\end{equation} If we wish to create a phase mode analysis stamp for the capacitor we need to replace the voltage with the voltage-phase relation. i_{C1} = C1\\frac{\\Phi_0}{2\\pi}\\frac{d^2\\phi}{dt} This second order differential needs to be expanded using the trapezoidal rule: {I_{C1}}_{n} = \\frac{C1\\Phi_0}{2\\pi}\\left[ \\frac{2}{h_n} \\left({\\frac{d\\phi}{dt}}_{n} - {\\frac{d\\phi}{dt}}_{n-1}\\right) - \\left(\\frac{d^2\\phi}{dt}\\right)_{n-1} \\right] {I_{C1}}_{n} = \\frac{C1\\Phi_0}{\\pi h_n} \\left({\\frac{d\\phi}{dt}}_{n} - {\\frac{d\\phi}{dt}}_{n-1}\\right) -{I_{C1}}_{n-1} {I_{C1}}_{n} = \\frac{2C1\\Phi_0}{\\pi h_n^2} {\\phi}_{n} - \\frac{2C1\\Phi_0}{\\pi h_n^2} {\\phi}_{n-1} - \\frac{2C1\\Phi_0}{\\pi h_n}{\\frac{d\\phi}{dt}}_{n-1} -{I_{C1}}_{n-1} \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n} - {\\phi}_{n} = -{\\phi}_{n-1} - h_n{\\frac{d\\phi}{dt}}_{n-1} - \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n-1} {\\phi}_{n} - \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n} = {\\phi}_{n-1} + h_n{\\frac{d\\phi}{dt}}_{n-1} + \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n-1} Which leads to the phase component stamp matrix: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{\\pi h_n^2}{2C1\\Phi_0} \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{C1} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ {\\phi}_{n-1} + h_n{\\frac{d\\phi}{dt}}_{n-1} + \\frac{\\pi h_n^2}{2C1\\Phi_0}{I_{C1}}_{n-1} \\end{bmatrix} \\end{equation}","title":"Capacitor"},{"location":"comp_stamps/#josephson-junction","text":"Fig. 3 - A basic Josephson junction with current flowing through it The Josephson junction shown in Figure 3 is based on the resistively and capacitivrely shunted junction (RCSJ) model. To determine the junction current, the summation of the currents through all three branches of the RCSJ is required. If we use the basic sinusoidal of the phase to represenent the junction branch, we formulate the total current as: I_{B1} = I_c \\sin{\\phi} + \\frac{V_{12}}{R} + C\\frac{dV_{12}}{dt} Which when expanded with the trapezoidal rule becomes: {I_{B1}}_{n} = I_c\\sin{\\phi_n} + \\frac{V_{n}}{R} + \\frac{2C}{h_n}(V_{n} - V_{n-1}) - C{\\frac{dV}{dt}}_{n-1} -\\frac{V_{n}}{R} - \\frac{2C}{h_{n}}V_{n} + I_{B1_{n}} = I_{c}\\sin{\\phi_{n}} - \\frac{2C}{h_n}V_{n-1}-C\\frac{dV}{dt}_{n-1} (\\frac{1}{R} + \\frac{2C}{h_n})V_n - {I_{B1}}_{n} = -I_c\\sin{\\phi_n} + \\frac{2C}{h_n}V_{n-1} + C{\\frac{dV}{dt}}_{n-1} V_{n} - \\frac{h_{n}R}{h_{n} + 2RC}I_{B1_{n}} = \\left(\\frac{h_{n}R}{h_{n} + 2RC}\\right)\\left(-I_{c}\\sin{\\phi_{n}} + \\frac{2C}{h_{n}}V_{n-1} + C\\frac{dV}{dt}_{n-1}\\right) This equation depends on the phase at the present time step, which needs to be solved. Phase is not, however, solved and we therefore need to use the voltage-phase relationship to find a voltage dependent solution for the phase: V_n = \\frac{\\hbar}{2e}{\\frac{d\\phi}{dt}}_{n} V_{n} = \\frac{2}{h_n}\\frac{\\hbar}{2e}(\\phi_n - \\phi_{n-1}) - V_{n-1} V_n - \\frac{\\hbar}{h_n e}\\phi_{n} = - \\frac{\\hbar}{h_n e}\\phi_{n-1} - V_{n-1} We can now combine these two equations to form the component stamp matrix: \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{\\hbar}{h_n e} & 0 \\\\ 1 & -1 & 0 & - \\frac{h_{n}R}{h_{n} + 2RC} \\end{bmatrix} \\begin{bmatrix} V_1 \\\\ V_2 \\\\ \\phi_{n}\\\\ I_{B1_{n}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -\\frac{\\hbar}{h_n e}\\phi_{n-1} - V_{n-1} \\\\ I_{s} \\end{bmatrix} \\end{equation} Where I_{s} = \\left(\\frac{h_{n}R}{h_{n} + 2RC}\\right)\\left(-I_{c}\\sin{\\phi_{n}} + \\frac{2C}{h_{n}}V_{n-1} + C\\frac{dV}{dt}_{n-1}\\right) It is, however, not possible to use the phase value for the current time step in the calculation of the current time step, we therefore have to rely on an estimated phase value based on previous values. We define this estimation as: \\phi_n^0=\\phi_{n-1}+\\frac{h_n e}{\\hbar}(V_{n-1} + v_n^0) v_n^0=V_{n-1}+h_n{\\frac{dV}{dt}}_{n-1} The current phase case is rather basic and we therefore replace this term with the more general term defined by Haberkorn[ haberkorn ]: I_s = \\frac{\\pi\\Delta}{2eR_N}\\frac{\\sin{\\phi}}{\\sqrt{1 - \\overline{D}\\sin^2\\left(\\frac{\\phi}{2}\\right)}}\\tanh\\left[\\frac{\\Delta}{2k_BT}\\sqrt{1-\\overline{D}\\sin^2\\left(\\frac{\\phi}{2}\\right)}\\right] This equation introduces temperature dependence within the junction model through \\Delta : \\Delta_0 = 1.76k_BT_c \\Delta = \\Delta_0\\sqrt{\\cos\\left[\\frac{\\pi}{2}\\left(\\frac{T}{T_c}\\right)^2\\right]} with T , the boiling point of liquid Helium (4.2K), T_c the critical temperature of Niobium (9.1K) and k_B is Boltzmann's constant for average kinetic energy of particles. The resistance value R_N is defined as: R_N = \\frac{\\pi\\Delta}{2eI_c}\\tanh\\left(\\frac{\\Delta}{2k_{B}T}\\right) This allows us to change the characteristics of the tunnel current by simply altering the transparency value \\overline{D} . For values of \\overline{D} \\ll 1 the equation becomes the normal sinusoidal equation whereas for large values of \\overline{D} it becomes the non-sinusoidal ballistic tunneling equation. To define the Josephson junction in phase we simply swap the voltage and phase of the component previously identified. The equations remain the same since the Josephson junction is already a phase element. \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{h_n e}{\\hbar} & 0 \\\\ 0 & 0 & 1 & - \\frac{h_{n}R}{h_{n} + 2RC} \\end{bmatrix} \\begin{bmatrix} \\phi_1 \\\\ \\phi_2 \\\\ V_{n}\\\\ I_{B1_{n}} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\phi_{n-1} + \\frac{h_n e}{\\hbar}V_{n-1} \\\\ I_{s} \\end{bmatrix} \\end{equation}","title":"Josephson Junction"},{"location":"comp_stamps/#voltage-source","text":"Fig. 4 - A basic voltage source A voltage source is nothing more than is implied. It is a source of voltage, this indicates that the voltage at any time step is known. We can therefore easily create a component stamp matrix in the form: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\\\ I_{V1} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ V1 \\end{bmatrix} \\end{equation} The phase version of this element simply sees the voltage replaced with the voltage-phase relation: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{V1} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\frac{\\Phi_0}{\\pi h_n}(V_n - V_{n-1}) + \\phi_{n-1} \\end{bmatrix} \\end{equation}","title":"Voltage Source"},{"location":"comp_stamps/#current-source","text":"Fig. 5 - A basic current source A current source is, as implied, a current that is known at every time step in the simulation. It can therefore simply be applied where needed on the RHS. \\begin{equation} \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\end{bmatrix} = \\begin{bmatrix} -I1\\\\ I1 \\end{bmatrix} \\end{equation}","title":"Current Source"},{"location":"comp_stamps/#phase-source","text":"Like a voltage source simply applies a phase where needed within the circuit. \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ I_{\\phi} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ \\phi_n \\end{bmatrix} \\end{equation}","title":"Phase Source"},{"location":"comp_stamps/#transmission-line","text":"Fig. 6 - A basic transmission line model A transmission line is, at present, simply a delay element where the delay T_D and impedence Z_0 define the length of the transmission line. At present we model the transmission line as an ideal element without any losses. We will in future implement a more accurate model of the transmission line. The equations that govern this lossless transmission line are: v_{12}(t)-Z_0i_1(t) = v_{34}(t-T_D)+Z_0\\centerdot i_2(t-T_D) v_{34}(t)-Z_0i_2(t) = v_{12}(t-T_D)+Z_0\\centerdot i_1(t-T_D) which leads to {V_{12}}_{n}-Z_0{I_1}_{n}={V_{34}}_{n-k}+Z_0{I_2}_{n-k} {V_{34}}_{n}-Z_0{I_2}_{n}={V_{12}}_{n-k}+Z_0{I_1}_{n-k} where k=\\frac{T_D}{h_n} Which allows us to create a component stamp matrix \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -Z_0 & 0 \\\\ 0 & 0 & 1 & -1 & 0 & -Z_0 \\end{bmatrix} \\begin{bmatrix} V_{12} \\\\ V_{21} \\\\ V_{34} \\\\ V_{43} \\\\ I_{1} \\\\ I_{2} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ 0 \\\\ 0 \\\\ {V_{34}}_{n-k}+Z_0{I_2}_{n-k} \\\\ {V_{12}}_{n-k}+Z_0{I_1}_{n-k} \\end{bmatrix} \\end{equation} The phase equations for the transmission line are: \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{12}}{dt}}_{n} - Z_0 {I_{1}}_{n} = \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{34}}{dt}}_{n-k} + Z_0 {I_{2}}_{n-k} \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{34}}{dt}}_{n} - Z_0 {I_{2}}_{n} = \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{12}}{dt}}_{n-k} + Z_0 {I_{1}}_{n-k} Since the equations are reciprocal, we only work with one side to simplify the rest of the equations. We rewrite this equation in terms of the differential as follows: \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{12}}{dt}}_{n} = Z_0 {I_{1}}_{n} + \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{34}}{dt}}_{n-k} + Z_0 {I_{2}}_{n-k} We now expand this using the trapezoidal method as: \\frac{\\Phi_0}{2\\pi}\\frac{2}{h_{n}}\\left(\\phi_{12_{n}} - \\phi_{12_{n-1}}\\right) - \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{12}}{dt}_{n-1} = Z_{0}I_{1_{n}}\\\\ + \\frac{\\Phi_0}{2\\pi}\\left(\\phi_{34_{n-k}} - \\phi_{34_{n-k-1}}\\right) - \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{34}}{dt}_{n-k-1} + Z_{0}I_{2_{n-k}} and substitute the unexpanded equation into the derivative: \\frac{\\Phi_0}{2\\pi}\\frac{2}{h_{n}}\\left(\\phi_{12_{n}} - \\phi_{12_{n-1}}\\right) - Z_0 {I_{1}}_{n-1} + \\frac{\\Phi_0}{2\\pi}{\\frac{d\\phi_{34}}{dt}}_{n-k-1} + Z_0 {I_{2}}_{n-k-1} = Z_{0}I_{1_{n}}\\\\ + \\frac{\\Phi_0}{2\\pi}\\left(\\phi_{34_{n-k}} - \\phi_{34_{n-k-1}}\\right) - \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_{34}}{dt}_{n-k-1} + Z_{0}I_{2_{n-k}} Simplifying this equation results in: \\phi_{12_{n}} - \\frac{2\\pi h_{n}Z_{0}}{2\\Phi_{0}}I_{1_{n}} = \\frac{2\\pi h_{n}Z_{0}}{2\\Phi_{0}}\\left(I_{1_{n-1}} + I_{2_{n-k}} - I_{2_{n-k-1}}\\right) + \\phi_{12_{n-1}} +\\phi_{34_{n-k}} - \\phi_{34_{n-k-1}} With the reciprocal: {\\phi_{34}}_{n} - \\frac{2\\pi h_n Z_0}{\\Phi_0}{2I_{2}}_{n} = \\frac{2\\pi h_n Z_0}{2\\Phi_0}\\left(I_{2_{n-1}} + I_{1_{n-k}} - I_{1_{n-k-1}}\\right) + {\\phi_{34}}_{n-1} +\\phi_{12_{n-k}} - \\phi_{12_{n-k-1}} This leads to the component stamp matrix: \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & - \\frac{2\\pi h_n Z_0}{2 \\Phi_0} & 0 \\\\ 0 & 0 & 1 & -1 & 0 & - \\frac{2\\pi h_n Z_0}{2\\Phi_0} \\end{bmatrix} \\begin{bmatrix} \\phi_{12} \\\\ \\phi_{21} \\\\ \\phi_{34} \\\\ \\phi_{43} \\\\ I_{1} \\\\ I_{2} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0 \\\\ 0 \\\\ 0 \\\\ V_{T1} \\\\ V_{T2} \\end{bmatrix} \\end{equation} With V_{T1} and V_{T2} the RHS of the expanded equations above.","title":"Transmission Line"},{"location":"comp_stamps/#mutual-inductance","text":"Fig. 7 - Mutual inductance model Mutual inductance allows simulation of coupling between inductors. This coupling adds an additional term to the inductor equation: v_{L1}(t) = L1 \\frac{di_{1}(t)}{dt} + M\\frac{di_2(t)}{dt} v_{L2}(t) = L2 \\frac{di_{2}(t)}{dt} + M\\frac{di_1(t)}{dt} with M = k\\sqrt{L_1 L_2} We expand these equations to: {V_{L1}}_{n} - \\frac{2L_1}{h_n}{I_{1}}_{n} - \\frac{2M}{h_n}{I_2}_{n} = - \\frac{2L_1}{h_n}{I_{1}}_{n-1} - \\frac{2M}{h_n}{I_2}_{n-1} - {V_{L1}}_{n-1} {V_{L2}}_{n} - \\frac{2L_2}{h_n}{I_{2}}_{n} - \\frac{2M}{h_n}{I_1}_{n} = - \\frac{2L_2}{h_n}{I_{2}}_{n-1} - \\frac{2M}{h_n}{I_1}_{n-1} - {V_{L2}}_{n-1} This leads to the component stamp matrix: \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -\\frac{2L_1}{h_n} & -\\frac{2M}{h_n} \\\\ 0 & 0 & 1 & -1 & -\\frac{2M}{h_n} & -\\frac{2L_2}{h_n} \\\\ \\end{bmatrix} \\begin{bmatrix} V_{L1} \\\\ -V_{L1} \\\\ V_{L2} \\\\ -V_{L2} \\\\ I_{L1} \\\\ I_{L2} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\0 \\\\ 0 \\\\ \\frac{2L_1}{h_n}{I_{1}}_{n-1} - \\frac{2M}{h_n}{I_2}_{n-1} - {V_{L1}}_{n-1} \\\\ - \\frac{2L_2}{h_n}{I_{2}}_{n-1} - \\frac{2M}{h_n}{I_1}_{n-1} - {V_{L2}}_{n-1} \\end{bmatrix} \\end{equation} The phase variant of this \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_1}{dt} = L_1\\frac{di_1}{dt} + M\\frac{di_2}{dt} \\frac{\\Phi_0}{2\\pi}\\frac{d\\phi_2}{dt} =M\\frac{di_1}{dt} + L_2\\frac{di_2}{dt} With integration on both sides \\frac{\\Phi_0}{2\\pi}\\phi_1 = L_1I_1 + MI_2 \\frac{\\Phi_0}{2\\pi}\\phi_2 = MI_1 + L_2I_2 This leads to a quite simplified component stamp matrix \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & -\\frac{2\\pi}{\\Phi_0}L_1 & -\\frac{2\\pi}{\\Phi_0}M \\\\ 0 & 0 & 1 & -1 & -\\frac{2\\pi}{\\Phi_0}M & -\\frac{2\\pi}{\\Phi_0}L_2 \\\\ \\end{bmatrix} \\begin{bmatrix} \\phi_{L1} \\\\ -\\phi_{L1} \\\\ \\phi_{L2} \\\\ -\\phi_{L2} \\\\ I_{L1} \\\\ I_{L2} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\0 \\\\ 0 \\\\0 \\\\ 0 \\end{bmatrix} \\end{equation}","title":"Mutual inductance"},{"location":"comp_stamps/#current-controlled-current-source","text":"Fig. 8 - Current controlled current source model Current controlled current source allows modulation of current in a particular branch through the current in a remote branch. I_{out} = \\beta I_{in} V_{1} - V_{2} = 0 \\beta = value \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & \\frac{1}{\\beta} \\\\ 0 & 0 & 0 & 0 & -\\frac{1}{\\beta} \\\\ 0 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 & -1 \\\\ 1 & -1 & 0 & 0 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V_{3}\\\\ V_{4}\\\\ I_{out} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation}","title":"Current Controlled Current Source"},{"location":"comp_stamps/#current-controlled-voltage-source","text":"Fig. 9 - Current controlled voltage source model Current controlled voltage source allows the modulation of a voltage node through a remote current source. V_{1} - V_{2} = 0 V_{3} - V_{4} = \\mu I_{in} \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 0 & -1 & 0\\ 0 & 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & 0 & -1\\\\ 0 & 0 & 1 & -1 & -\\mu & 0\\\\ 1 & -1 & 0 & 0 & 0 & -\\mu \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V{3}\\\\ V{4}\\\\ I_{in}\\\\ I_{out}\\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation}","title":"Current Controlled Voltage Source"},{"location":"comp_stamps/#voltage-controlled-current-source","text":"Fig. 10 - Voltage controlled current source model Voltage controlled current source allows the modulation of a current in a branch through a remote voltage source. \\alpha(V_{1} - V_{2}) = I_{out} \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & -1\\\\ 1 & -1 & 0 & 0 & -\\frac{1}{\\alpha} \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V{3}\\\\ V{4}\\\\ I_{in} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation}","title":"Voltage Controlled Current Source"},{"location":"comp_stamps/#voltage-controlled-voltage-source","text":"Fig. 11 - Voltage controlled voltage source model Voltage controlled current source allows the modulation of a current in a branch through a remote voltage source. A(V_{1} - V_{2}) = V_{3}-V_{4} \\begin{equation} \\begin{bmatrix} 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & -1\\\\ G & -G & 1 & -1 & 0 \\end{bmatrix} \\begin{bmatrix} V_{1}\\\\ V_{2}\\\\ V{3}\\\\ V{4}\\\\ I_{out} \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} \\end{equation} This concludes the section on component stamps and we move on to the Syntax Guide .center { display: block; margin: 0 auto; } haberkorn Haberkorn W., Knauer H., Richter J.: A theoretical study of the current-phase relation in Josephson contacts . physica status solidi (a). 47 , (1978)","title":"Voltage Controlled Voltage Source"},{"location":"ex_usage/","text":"Example Usage Basic JTL Example In this section we provide example usage of the simulator. In the test subfolder of the repository the user wil find multiple example files that can be used with the simulator. In this example we will make use of the ex_jtl_basic.cir file. This is a basic Josephson transmission line (JTL) that simply carries the single flux quantum pulse from input to output. * Example JTL Basic B01 3 7 jmod area=2.16 B02 6 8 jmod area=2.16 IB01 0 1 pwl(0 0 5p 280u) L01 4 3 2p L02 3 2 2.425p L03 2 6 2.425p L04 6 5 2.031p LP01 0 7 0.086p LP02 0 8 0.096p LPR01 2 1 0.278p LRB01 7 9 0.086p LRB02 8 10 0.086p RB01 9 3 5.23 RB02 10 6 5.23 ROUT 5 0 2 VIN 4 0 pwl(0 0 300p 0 302.5p 827.13u 305p 0 600p 0 602.5p 827.13u 605p 0) .model jmod jj(rtype=1, vg=2.8mV, cap=0.07pF, r0=160, rN=16, icrit=0.1mA) .tran 0.25p 1000p 0 0.25p .print DEVV VIN .print DEVI ROUT .print PHASE B01 .print PHASE B02 .end Label + Node - Node Value R L C B M Only the device voltage (DEVV) of the input source (VIN), the device current (DEVI) of the output resistor (ROUT) and the phase of both junctions are requested to be store. The simulation executes for a total of 1000ps and produces a result every 0.25ps which results in 4000 points of data for each requested variable. We simulate this circuit (on a CentOS 7 machine) using the command: ./josim-cli -o ex_jtl_basic.csv ex_jtl_basic.cir This simulation is almost instant, given the size of the problem and should take no longer than 10ms to complete. Fig. 1 - JoSIM JTL example commandline output. The results of this simulation are stored in the ex_jtl_basic.csv file of which an excerpt of the two events is shown below. time,CURRENT_ROUT,DEVV_VIN,PHASE_B01,PHASE_B02 0.0000000000000000e+00,0.0000000000000000e+00,0.0000000000000000e+00,0.0000000000000000e+00,0.0000000000000000e+00 2.4999999999999999e-13,5.2618741532587213e-07,0.0000000000000000e+00,1.7590417807527424e-03,1.7625663594260056e-03 . . . . . . . . . . . . . . . 2.9950000000000000e-10,1.2602334650362215e-22,0.0000000000000000e+00,4.0463239580396271e-01,6.1557778681614406e-01 2.9974999999999997e-10,-8.3663517212216735e-22,0.0000000000000000e+00,4.0463239580396271e-01,6.1557778681614406e-01 3.0000000000000000e-10,-1.5966746163438487e-21,0.0000000000000000e+00,4.0463239580396271e-01,6.1557778681614406e-01 3.0024999999999997e-10,1.2138210460568509e-08,8.2712999999999992e-05,4.0588849169065189e-01,6.1561844609608551e-01 3.0050000000000000e-10,8.3269106098336399e-08,1.6542599999999998e-04,4.1373721572716365e-01,6.1593850563537267e-01 3.0074999999999997e-10,3.1874311596945211e-07,2.4813899999999998e-04,4.3783030030526732e-01,6.1722434414431326e-01 3.0099999999999999e-10,8.8716300244636592e-07,3.3085199999999997e-04,4.8814712164259011e-01,6.2078477555864586e-01 3.0125000000000002e-10,1.9855061368009524e-06,4.1356499999999996e-04,5.7113817950274370e-01,6.2846436865880417e-01 3.0149999999999999e-10,3.7775100494815062e-06,4.9627799999999995e-04,6.8883988431911958e-01,6.4225058535926782e-01 3.0175000000000002e-10,6.3359283607783743e-06,5.7899099999999995e-04,8.4054979432033217e-01,6.6376618522513120e-01 3.0199999999999999e-10,9.6268557444681243e-06,6.6170399999999994e-04,1.0258326634823722e+00,6.9395688283705226e-01 3.0225000000000002e-10,1.3552874679952160e-05,7.4441699999999993e-04,1.2475669537636640e+00,7.3318675289877544e-01 3.0249999999999999e-10,1.8042425566922425e-05,8.2712999999999992e-04,1.5144772973301901e+00,7.8175014313659197e-01 3.0275000000000001e-10,2.3132972521939297e-05,7.4441699999999993e-04,1.8411678233070754e+00,8.4057341009994713e-01 3.0299999999999999e-10,2.9026125783186692e-05,6.6170399999999994e-04,2.2453378998772728e+00,9.1179088131163233e-01 3.0325000000000001e-10,3.6115317782987027e-05,5.7899099999999995e-04,2.7485987257643534e+00,9.9913706309331773e-01 3.0349999999999999e-10,4.5004018307525714e-05,4.9627799999999995e-04,3.3796783185915840e+00,1.1083683692206756e+00 3.0375000000000001e-10,5.6484467501108440e-05,4.1356499999999996e-04,4.1592025708753528e+00,1.2477159562171136e+00 3.0399999999999998e-10,7.1294936682528957e-05,3.3085199999999997e-04,5.0434512532682056e+00,1.4274416884444263e+00 3.0425000000000001e-10,8.9601267490561153e-05,2.4813899999999998e-04,5.8716978821424979e+00,1.6569226427300268e+00 3.0449999999999998e-10,1.1064201526112140e-04,1.6542599999999998e-04,6.4323756562633472e+00,1.9399189619742534e+00 3.0475000000000001e-10,1.3305044637426826e-04,8.2712999999999992e-05,6.6189208102948909e+00,2.2725986145252426e+00 3.0499999999999998e-10,1.5575130808877477e-04,0.0000000000000000e+00,6.4943549761561137e+00,2.6479927374623258e+00 3.0525000000000001e-10,1.7885172860297336e-04,0.0000000000000000e+00,6.2272567013493418e+00,3.0641714808700860e+00 3.0549999999999998e-10,2.0379715833211554e-04,0.0000000000000000e+00,5.9948045018496323e+00,3.5290571354520934e+00 . . . . . . . . . . . . . . . 5.9949999999999995e-10,4.3212858202495744e-21,0.0000000000000000e+00,6.6878072510727549e+00,6.8987600821376667e+00 5.9975000000000002e-10,4.3137521994626109e-21,0.0000000000000000e+00,6.6878072510727549e+00,6.8987600821376667e+00 6.0000000000000000e-10,4.3078931225786343e-21,0.0000000000000000e+00,6.6878072510727549e+00,6.8987600821376667e+00 6.0024999999999997e-10,1.2138210460577924e-08,8.2712999999999992e-05,6.6890633469594443e+00,6.8988007414176078e+00 6.0049999999999994e-10,8.3269096666537856e-08,1.6542599999999998e-04,6.6969120695472864e+00,6.8991208009145337e+00 6.0075000000000002e-10,3.1874302598962546e-07,2.4813899999999998e-04,6.7210051436437208e+00,6.9004066390118268e+00 6.0099999999999999e-10,8.8716255780263208e-07,3.3085199999999997e-04,6.7713219264319413e+00,6.9039670683967049e+00 6.0124999999999997e-10,1.9855046057915069e-06,4.1356499999999996e-04,6.8543128850350286e+00,6.9116466546674440e+00 6.0149999999999994e-10,3.7775059001042050e-06,4.9627799999999995e-04,6.9720143838434145e+00,6.9254328535762175e+00 6.0175000000000002e-10,6.3359188963277667e-06,5.7899099999999995e-04,7.1237239212106864e+00,6.9469484148633018e+00 6.0199999999999999e-10,9.6268367676180748e-06,6.6170399999999994e-04,7.3090061730293270e+00,6.9771390393488719e+00 6.0224999999999996e-10,1.3552840137866662e-05,7.4441699999999993e-04,7.5307394915059733e+00,7.0163687836318234e+00 6.0250000000000004e-10,1.8042366960989605e-05,8.2712999999999992e-04,7.7976483370788721e+00,7.0649319712733414e+00 6.0275000000000001e-10,2.3132877643123393e-05,7.4441699999999993e-04,8.1243365485310051e+00,7.1237549237784270e+00 6.0299999999999999e-10,2.9025976163591970e-05,6.6170399999999994e-04,8.5285030132858992e+00,7.1949719126817717e+00 6.0324999999999996e-10,3.6115084492683834e-05,5.7899099999999995e-04,9.0317582599489015e+00,7.2823173512317032e+00 6.0350000000000004e-10,4.5003657487430368e-05,4.9627799999999995e-04,9.6628298406009119e+00,7.3915475072422705e+00 6.0375000000000001e-10,5.6483922613042281e-05,4.1356499999999996e-04,1.0442344928918883e+01,7.5308933521128347e+00 6.0399999999999998e-10,7.1294158923435432e-05,3.3085199999999997e-04,1.1326588459213040e+01,7.7106166231913225e+00 6.0424999999999996e-10,8.9600246674970675e-05,2.4813899999999998e-04,1.2154840250727050e+01,7.9400944882309208e+00 6.0450000000000003e-10,1.1064078717562771e-04,1.6542599999999998e-04,1.2715533169224782e+01,8.2230874188094543e+00 6.0475000000000001e-10,1.3304905904021097e-04,8.2712999999999992e-05,1.2902095586396108e+01,8.5557636754469328e+00 6.0499999999999998e-10,1.5574976667867628e-04,0.0000000000000000e+00,1.2777541168233270e+01,8.9311543029884017e+00 6.0524999999999995e-10,1.7884995879749259e-04,0.0000000000000000e+00,1.2510445228968999e+01,9.3473289350035067e+00 6.0550000000000003e-10,2.0379503512670802e-04,0.0000000000000000e+00,1.2277987682825806e+01,9.8122093480792216e+00 . . . . . . . . . . . . . . . 9.9925000000000004e-10,9.9776412773980053e-20,0.0000000000000000e+00,1.2970982106365490e+01,1.3181942377470081e+01 9.9949999999999991e-10,9.8740906314363196e-20,0.0000000000000000e+00,1.2970982106365490e+01,1.3181942377470081e+01 9.9974999999999999e-10,9.7932385381164065e-20,0.0000000000000000e+00,1.2970982106365490e+01,1.3181942377470081e+01 When this output result is plotted using the Python script mentioned in Technical Discussion the user will be presented with a visual representation of the result. Fig. 2 - JoSIM JTL example result output. Through the reperesentation of the results visually, the user can see the two SFQ pulses at the input and through the output resistor, as well as, the phases of the two junctions. The same process can be done for every example found in the test folder on the repository. Commandline Switches The command line interface has various switches which can be shown using the -h switch. Each of these switches will also be shown and discussed below. Switch Options Explanation -a 0 or 1 Sets the analysis type between Voltage and Phase mode --analysis= 0 is default -c 0 or 1 Sets the subcircuit convention used internally. 0 being JSIM. 1 being WRspice (standard SPICE) --convention= 0 is default -d 0 or 1 Sets the differential method to either trapezoidal or Gear. * --differential= 0 is default -h Displays the help menu that contains explanations for each of these switches. --help -i Input circuit netlist from standard input. --input -m Disables most output. * --minimal -o output filename Save the output to file as either .csv, .dat or raw --output= output.csv -p Enables an experimental parallel processing feature. This is still under construction and results might not be as intendend --parallel -V Enables verbose mode, displaying extra information with regards to the simulation --verbose -v Displays the version information for this version of the executable --version * Only available in v2.5 (testing) at time of writing. These switches can be fed to the executable in any order as long as it makes sense. With this being said, the simulator will treat the first non switch related string line as the input file. It would make perfect sense to then have a command line as follows: ./josim-cli -a 1 inputfile \u2014output=outputfile.csv -c 1 As this will see analysis as 1 , convention as 1 and the output file as outputfile.csv . This leaves the only non switch related string being inputfile . It would, however, not make sense to have convention or analysis set to a value that is not a valid option or omitting the option for the switch completely. An example would be if the command is given as: ./josim-cli -a inputfile -c This would not work and would tell the user that command switches are invalid. Additionally, when the version command is sent through the program only prints the version and then exits. This is similar to the help command, which also only prints the menu and exits. .center { display: block; margin: 0 auto; }","title":"Example Usage"},{"location":"ex_usage/#example-usage","text":"","title":"Example Usage"},{"location":"ex_usage/#basic-jtl-example","text":"In this section we provide example usage of the simulator. In the test subfolder of the repository the user wil find multiple example files that can be used with the simulator. In this example we will make use of the ex_jtl_basic.cir file. This is a basic Josephson transmission line (JTL) that simply carries the single flux quantum pulse from input to output. * Example JTL Basic B01 3 7 jmod area=2.16 B02 6 8 jmod area=2.16 IB01 0 1 pwl(0 0 5p 280u) L01 4 3 2p L02 3 2 2.425p L03 2 6 2.425p L04 6 5 2.031p LP01 0 7 0.086p LP02 0 8 0.096p LPR01 2 1 0.278p LRB01 7 9 0.086p LRB02 8 10 0.086p RB01 9 3 5.23 RB02 10 6 5.23 ROUT 5 0 2 VIN 4 0 pwl(0 0 300p 0 302.5p 827.13u 305p 0 600p 0 602.5p 827.13u 605p 0) .model jmod jj(rtype=1, vg=2.8mV, cap=0.07pF, r0=160, rN=16, icrit=0.1mA) .tran 0.25p 1000p 0 0.25p .print DEVV VIN .print DEVI ROUT .print PHASE B01 .print PHASE B02 .end Label + Node - Node Value R L C B M Only the device voltage (DEVV) of the input source (VIN), the device current (DEVI) of the output resistor (ROUT) and the phase of both junctions are requested to be store. The simulation executes for a total of 1000ps and produces a result every 0.25ps which results in 4000 points of data for each requested variable. We simulate this circuit (on a CentOS 7 machine) using the command: ./josim-cli -o ex_jtl_basic.csv ex_jtl_basic.cir This simulation is almost instant, given the size of the problem and should take no longer than 10ms to complete. Fig. 1 - JoSIM JTL example commandline output. The results of this simulation are stored in the ex_jtl_basic.csv file of which an excerpt of the two events is shown below. time,CURRENT_ROUT,DEVV_VIN,PHASE_B01,PHASE_B02 0.0000000000000000e+00,0.0000000000000000e+00,0.0000000000000000e+00,0.0000000000000000e+00,0.0000000000000000e+00 2.4999999999999999e-13,5.2618741532587213e-07,0.0000000000000000e+00,1.7590417807527424e-03,1.7625663594260056e-03 . . . . . . . . . . . . . . . 2.9950000000000000e-10,1.2602334650362215e-22,0.0000000000000000e+00,4.0463239580396271e-01,6.1557778681614406e-01 2.9974999999999997e-10,-8.3663517212216735e-22,0.0000000000000000e+00,4.0463239580396271e-01,6.1557778681614406e-01 3.0000000000000000e-10,-1.5966746163438487e-21,0.0000000000000000e+00,4.0463239580396271e-01,6.1557778681614406e-01 3.0024999999999997e-10,1.2138210460568509e-08,8.2712999999999992e-05,4.0588849169065189e-01,6.1561844609608551e-01 3.0050000000000000e-10,8.3269106098336399e-08,1.6542599999999998e-04,4.1373721572716365e-01,6.1593850563537267e-01 3.0074999999999997e-10,3.1874311596945211e-07,2.4813899999999998e-04,4.3783030030526732e-01,6.1722434414431326e-01 3.0099999999999999e-10,8.8716300244636592e-07,3.3085199999999997e-04,4.8814712164259011e-01,6.2078477555864586e-01 3.0125000000000002e-10,1.9855061368009524e-06,4.1356499999999996e-04,5.7113817950274370e-01,6.2846436865880417e-01 3.0149999999999999e-10,3.7775100494815062e-06,4.9627799999999995e-04,6.8883988431911958e-01,6.4225058535926782e-01 3.0175000000000002e-10,6.3359283607783743e-06,5.7899099999999995e-04,8.4054979432033217e-01,6.6376618522513120e-01 3.0199999999999999e-10,9.6268557444681243e-06,6.6170399999999994e-04,1.0258326634823722e+00,6.9395688283705226e-01 3.0225000000000002e-10,1.3552874679952160e-05,7.4441699999999993e-04,1.2475669537636640e+00,7.3318675289877544e-01 3.0249999999999999e-10,1.8042425566922425e-05,8.2712999999999992e-04,1.5144772973301901e+00,7.8175014313659197e-01 3.0275000000000001e-10,2.3132972521939297e-05,7.4441699999999993e-04,1.8411678233070754e+00,8.4057341009994713e-01 3.0299999999999999e-10,2.9026125783186692e-05,6.6170399999999994e-04,2.2453378998772728e+00,9.1179088131163233e-01 3.0325000000000001e-10,3.6115317782987027e-05,5.7899099999999995e-04,2.7485987257643534e+00,9.9913706309331773e-01 3.0349999999999999e-10,4.5004018307525714e-05,4.9627799999999995e-04,3.3796783185915840e+00,1.1083683692206756e+00 3.0375000000000001e-10,5.6484467501108440e-05,4.1356499999999996e-04,4.1592025708753528e+00,1.2477159562171136e+00 3.0399999999999998e-10,7.1294936682528957e-05,3.3085199999999997e-04,5.0434512532682056e+00,1.4274416884444263e+00 3.0425000000000001e-10,8.9601267490561153e-05,2.4813899999999998e-04,5.8716978821424979e+00,1.6569226427300268e+00 3.0449999999999998e-10,1.1064201526112140e-04,1.6542599999999998e-04,6.4323756562633472e+00,1.9399189619742534e+00 3.0475000000000001e-10,1.3305044637426826e-04,8.2712999999999992e-05,6.6189208102948909e+00,2.2725986145252426e+00 3.0499999999999998e-10,1.5575130808877477e-04,0.0000000000000000e+00,6.4943549761561137e+00,2.6479927374623258e+00 3.0525000000000001e-10,1.7885172860297336e-04,0.0000000000000000e+00,6.2272567013493418e+00,3.0641714808700860e+00 3.0549999999999998e-10,2.0379715833211554e-04,0.0000000000000000e+00,5.9948045018496323e+00,3.5290571354520934e+00 . . . . . . . . . . . . . . . 5.9949999999999995e-10,4.3212858202495744e-21,0.0000000000000000e+00,6.6878072510727549e+00,6.8987600821376667e+00 5.9975000000000002e-10,4.3137521994626109e-21,0.0000000000000000e+00,6.6878072510727549e+00,6.8987600821376667e+00 6.0000000000000000e-10,4.3078931225786343e-21,0.0000000000000000e+00,6.6878072510727549e+00,6.8987600821376667e+00 6.0024999999999997e-10,1.2138210460577924e-08,8.2712999999999992e-05,6.6890633469594443e+00,6.8988007414176078e+00 6.0049999999999994e-10,8.3269096666537856e-08,1.6542599999999998e-04,6.6969120695472864e+00,6.8991208009145337e+00 6.0075000000000002e-10,3.1874302598962546e-07,2.4813899999999998e-04,6.7210051436437208e+00,6.9004066390118268e+00 6.0099999999999999e-10,8.8716255780263208e-07,3.3085199999999997e-04,6.7713219264319413e+00,6.9039670683967049e+00 6.0124999999999997e-10,1.9855046057915069e-06,4.1356499999999996e-04,6.8543128850350286e+00,6.9116466546674440e+00 6.0149999999999994e-10,3.7775059001042050e-06,4.9627799999999995e-04,6.9720143838434145e+00,6.9254328535762175e+00 6.0175000000000002e-10,6.3359188963277667e-06,5.7899099999999995e-04,7.1237239212106864e+00,6.9469484148633018e+00 6.0199999999999999e-10,9.6268367676180748e-06,6.6170399999999994e-04,7.3090061730293270e+00,6.9771390393488719e+00 6.0224999999999996e-10,1.3552840137866662e-05,7.4441699999999993e-04,7.5307394915059733e+00,7.0163687836318234e+00 6.0250000000000004e-10,1.8042366960989605e-05,8.2712999999999992e-04,7.7976483370788721e+00,7.0649319712733414e+00 6.0275000000000001e-10,2.3132877643123393e-05,7.4441699999999993e-04,8.1243365485310051e+00,7.1237549237784270e+00 6.0299999999999999e-10,2.9025976163591970e-05,6.6170399999999994e-04,8.5285030132858992e+00,7.1949719126817717e+00 6.0324999999999996e-10,3.6115084492683834e-05,5.7899099999999995e-04,9.0317582599489015e+00,7.2823173512317032e+00 6.0350000000000004e-10,4.5003657487430368e-05,4.9627799999999995e-04,9.6628298406009119e+00,7.3915475072422705e+00 6.0375000000000001e-10,5.6483922613042281e-05,4.1356499999999996e-04,1.0442344928918883e+01,7.5308933521128347e+00 6.0399999999999998e-10,7.1294158923435432e-05,3.3085199999999997e-04,1.1326588459213040e+01,7.7106166231913225e+00 6.0424999999999996e-10,8.9600246674970675e-05,2.4813899999999998e-04,1.2154840250727050e+01,7.9400944882309208e+00 6.0450000000000003e-10,1.1064078717562771e-04,1.6542599999999998e-04,1.2715533169224782e+01,8.2230874188094543e+00 6.0475000000000001e-10,1.3304905904021097e-04,8.2712999999999992e-05,1.2902095586396108e+01,8.5557636754469328e+00 6.0499999999999998e-10,1.5574976667867628e-04,0.0000000000000000e+00,1.2777541168233270e+01,8.9311543029884017e+00 6.0524999999999995e-10,1.7884995879749259e-04,0.0000000000000000e+00,1.2510445228968999e+01,9.3473289350035067e+00 6.0550000000000003e-10,2.0379503512670802e-04,0.0000000000000000e+00,1.2277987682825806e+01,9.8122093480792216e+00 . . . . . . . . . . . . . . . 9.9925000000000004e-10,9.9776412773980053e-20,0.0000000000000000e+00,1.2970982106365490e+01,1.3181942377470081e+01 9.9949999999999991e-10,9.8740906314363196e-20,0.0000000000000000e+00,1.2970982106365490e+01,1.3181942377470081e+01 9.9974999999999999e-10,9.7932385381164065e-20,0.0000000000000000e+00,1.2970982106365490e+01,1.3181942377470081e+01 When this output result is plotted using the Python script mentioned in Technical Discussion the user will be presented with a visual representation of the result. Fig. 2 - JoSIM JTL example result output. Through the reperesentation of the results visually, the user can see the two SFQ pulses at the input and through the output resistor, as well as, the phases of the two junctions. The same process can be done for every example found in the test folder on the repository.","title":"Basic JTL Example"},{"location":"ex_usage/#commandline-switches","text":"The command line interface has various switches which can be shown using the -h switch. Each of these switches will also be shown and discussed below. Switch Options Explanation -a 0 or 1 Sets the analysis type between Voltage and Phase mode --analysis= 0 is default -c 0 or 1 Sets the subcircuit convention used internally. 0 being JSIM. 1 being WRspice (standard SPICE) --convention= 0 is default -d 0 or 1 Sets the differential method to either trapezoidal or Gear. * --differential= 0 is default -h Displays the help menu that contains explanations for each of these switches. --help -i Input circuit netlist from standard input. --input -m Disables most output. * --minimal -o output filename Save the output to file as either .csv, .dat or raw --output= output.csv -p Enables an experimental parallel processing feature. This is still under construction and results might not be as intendend --parallel -V Enables verbose mode, displaying extra information with regards to the simulation --verbose -v Displays the version information for this version of the executable --version * Only available in v2.5 (testing) at time of writing. These switches can be fed to the executable in any order as long as it makes sense. With this being said, the simulator will treat the first non switch related string line as the input file. It would make perfect sense to then have a command line as follows: ./josim-cli -a 1 inputfile \u2014output=outputfile.csv -c 1 As this will see analysis as 1 , convention as 1 and the output file as outputfile.csv . This leaves the only non switch related string being inputfile . It would, however, not make sense to have convention or analysis set to a value that is not a valid option or omitting the option for the switch completely. An example would be if the command is given as: ./josim-cli -a inputfile -c This would not work and would tell the user that command switches are invalid. Additionally, when the version command is sent through the program only prints the version and then exits. This is similar to the help command, which also only prints the menu and exits. .center { display: block; margin: 0 auto; }","title":"Commandline Switches"},{"location":"syntax/","text":"Syntax In this section we will attempt to provide the user with a comprehensive guide of the available syntax within JoSIM JoSIM is CaSe InSeNsItIvE as each line is cast to uppercase upon read-in. Each line follows similar syntax which uses the first non-blank space character as identifier. Each identifier tells JoSIM how to handle that specific line. Identifiers that start with a letter relate to physical components in the design, e.g. L, C, R. Lines of this kind almost always follows the same syntax in that it requires a label and two nodes. These nodes can be alphanumeric with the restriction of 0 and GND which indicate a grounded node. Additionally, the use of period ( . ) or vertical bars ( | ) in label or node names are prohibited as these are reserved characters within JoSIM. Lines that start with a period ( . ) indicate that the line relates in some way to simulation control. In this case whatever follows the period identifies the control, e.g. .tran, .print, .end. Comments are lines that start with an asterisk ( * ) or a pound sign ( # ). Comments are meant to be in a line of their own and will not work if placed at the end of a line. Lines that end with a plus sign ( + ) indicate that the line that follows is a continuation of this line. Internally the two lines will be combined. In most cases the VALUE of a component can be replaced by a variable name or an expression. Variables can be defined using the .PARAM control and expressions can be evaluated by encapsulating the expression in braces ( {} ). These will be discussed in detail further. Values in JoSIM can be modified with engineering notation or through suffixes. A list of the available suffixes is found below: Suffix Meaning Engineering Notation Equivalent F Femto 1E-15 P Pico 1E-12 N Nano 1E-9 U Micro 1E-6 M Milli 1E-3 K Kilo 1E3 MEG Mega 1E6 X G Giga 1E9 T Terra 1E12 We will now run through all the available physical components and their limitations. Any parameter surrounded by square brackets are optional and nested square brackets mean that the encapsulated parameter relies on the existance of the previous. Basic Components Resistor R Label PosNode NegNode VALUE The value of a resistor is in Ohms. Inductor L Label PosNode NegNode VALUE The value of an inductor is in Henry. Capacitor C Label PosNode NegNode VALUE The value of a capacitor is in Farad. Josephson Junction (JJ) B Label PosNode NegNode <PhaseNode> MODEL [< AREA >] A Josephson junction is a two terminal device but could also be defined with a third non-connected node to allow compatibility with WRspice. This node is not used in any way in JoSIM. The Josephson junction requires specification of a model name which can be defined anyware in the program using the control .MODEL . This model control has the following syntax .MODEL ModelName ModelType ([ MODEL PARAMETERS ]) The only junction model currently supported by JoSIM is the RCSJ model and thus the only available ModelType is jj with the following tunable parameters: Parameter Range Default Description RTYPE 0, 1 1 Linearisation model used VG or VGAP -\\(\\infty\\), \\(\\infty\\) 2.8E-3 Junction gap voltage IC or ICRIT -\\(\\infty\\), \\(\\infty\\) 1E-3 Junction critical current RN 0, \\(\\infty\\) 5 Junction normal resistance R0 0, \\(\\infty\\) 30 Junction subgap resistance C or CAP 0, \\(\\infty\\) 2.5E-12 Junction capacitance T 0, \\(\\infty\\) 4.2 Boiling point of liquid coolant TC 0, \\(\\infty\\) 9.1 Critical temperature of superconducting material DELV 0, \\(\\infty\\) 0.1E-3 Transitional voltage from subgap to normal D 0.0, 1 0.0 Point contact transparency affecting current phase relationship ICFCT or ICFACT 0, 1 \\(\\pi\\)/4 Ratio of critical current to quasiparticle step height PHI 0, n\\(\\pi\\) 0 Starting phase for junction The .model line is unique to the subcircuit it falls under and can thus allow different models with the same name under seperate subcircuits. If the model is not found under the subcircuit it will be searched for globally and if not found default values (default model) will be used instead. Transmission Line T Label PosNode1 NegNode1 PosNode2 NegNode2 TD=VALUE Z0=VALUE TD is the time delay in pico seconds. Z0 is the impedance in Ohms. Mutual Inductance K Label Inductor1 Inductor2 VALUE The value is the coupling factor k . Sources Voltage Source V Label PosNode NegNode SOURCETYPE Current Source I Label PosNode NegNode SOURCETYPE Phase Source P Label PosNode NegNode SOURCETYPE Source Types Piece Wise Linear (PWL) pwl(0 0 Time1 Amplitude1 ... TimeN AmplitudeN ) This source linearly interpolates amplitude values for every time point in the simulation between the specified amplitudes. The initial two values are required to be zero at the start of the simulation. Pulse pulse( A_1 A_2 [ T_D [ T_R [ T_F [ PW [ PER ]]]]] ) This source generates a pulse between two amplitudes ( A_1 & A_2 ), starts after T_D and has a rise and fall time ( T_R & T_F ), which default to the transient simulation step size. PW and PER refer to the pulse width and the period respectivrespectively. These values default to the transient simulation stop time when not specified. This source allows the continuous generation of a pulse at a set frequency. Sinusoidal sin( \b A_O A [ FREQ [ T_D [ THETA ]]] ) A source that generates a sinusoidal signal with A_O offset and A amplitude at a frequency of FREQ which defaults to 1/(Transient simulation stop time). T_D sets the stop time and THETA modulates the signal amplitude. The function generates a data point for each step in the transient simulation based on the following equation: f(t) = A_O + A\\sin (2\\pi FREQ(t-T_D))e^{-THETA(t-T_D)} Custom Waveform cus( wavefile T_S SF IM [ T_D PER] ) This source allows the generates a function based on the points inside the plain text wave file. This file should contain a single line of space seperated numbers. E.g 0 2 3 6 2 1 0 Each number in this line represents an amplitude seperated by time step T_S and scaled using scale factor SF . The values between the points are interpolated using either no interpolation (0), linear (1), cubic (2) or spline (3). The function can become periodic if PER is set to 1, whereby the pattern is repeated for the entire simulation. Control Commands The simulation engine requires control commands to know what to do with the components it has just been provided with. The most important of these control commands is the transient simulation command as no simulation can be performed without it. Simulation .tran T_{step} T_{stop} [ T_{start} ] This generates a simulation that runs from T_{start} (0 unless specified) until T_{stop} and generates a simulation point at every T_{step} between those two points. The difference between start and stop divided by the step size floored to the closest integer value indicates how many simulation steps there will be. JoSIM does not at present support any form of variable timestep input. It will in addition complain if a timestep is chosen that results in a phase step larger than 20% of 2 \\pi . Output A simulation is meaningless unless the results are stored or viewed in some way. In order to know which of these results are relevant and need to be stored the simulator needs output control commands. These output commands can be of either .print .plot .save Any of these commands can be followed by either of the following commands PrintType Device or Node PType(Device or Node) _0 ... PType(Device or Node) _n Where PrintType can be either device voltage ( DEVV ), device current ( DEVI ), device phase ( PHASE ), node voltage ( NODEV ) or node phase ( NODEP ). When specifying a device type store only a single device can be specified, but when a node type store is specified 2 nodes can be specified to store the difference between them. PType is shorthand for the above and can have multiple per line requests. PType can be either of V , I (or C ) or P followed by the device or node in brackets. If more than one device or node is specified by comma seperation (maximum 2) the difference between the two devices or nodes is stored. An additional save type exists that has the following syntax @ Device [ PType ] This stores the PType of the device specified. Subcircuits Subcircuits allow subdivision and reuse of smaller circuits within a larger design. When wrapped in a subcircuit control devices are allowed to have the same label names as specified elsewhere in the netlist as the subcircuit completely isolates them. Subcircuits have the following wrapping control syntax .subckt SubcktName IO Nodes ... .ends The SubcktName specifies the name of the subcircuit and IO Nodes specify the which nodes within the subcircuit connects to outside. A subcircuit can be used in the main netlist or another subcircuit (nesting) using the following syntax X Label SubcktName IO Nodes (JSIM mode) X Label IO Nodes SubcktName (WRspice (normal SPICE) mode) Additional features of the subcircuit include isolation of parameters (discussed next) and the ability to plot/print the devices or nodes within a subcircuit by specifying the device or node followed by either a . or a | and then the XLabel . i.e. .print v(14.X01) p(B01.X02) Subcircuits as mentioned before can also be nested almost indefinitely as they are expanded upon simulation. Parameters The final control command that is of importance in JoSIM is the parameters command with the following syntax .param VarName = Expression VarName is the variable name that can be used anywhere else in the circuit and Expression is a mathematical expression that is evaluated using an implementation of Dijkstra's shunting yard algorithm, whereby the expression is converted into reverse polish notation (RPN) and evaluated. Additionally, expressions can also contain other variables and parameters will be continuosly evaluated untill all variables are reduced to values. If variables are not defined the program will halt and produce an error. Control Block Any of the above controls can be wrapped inside a control block with the following syntax .control ... .endc Wherein all controls can be specified by omitting the usual prepending period to the command. Include JoSIM allows the use of a .include control card that uses the following syntax .include relative_path_to_file This command reads in the contents of the relevant file pointed to by the relevant path uppon parsing of the netlist essentially extending the netlist by the linked file. This is incredibly handy when large subcircuits are involved and reuse of subcircuits accross multiple files is required. This can also be used to house all the models used in simulation allowing a central point of alteration if the model is changed. Standard Input JoSIM now allows input from standard input allowing a line-by-line read in of a netlist until the .end card is found or alternatively the EOF character is returned.","title":"Syntax Guide"},{"location":"syntax/#syntax","text":"In this section we will attempt to provide the user with a comprehensive guide of the available syntax within JoSIM JoSIM is CaSe InSeNsItIvE as each line is cast to uppercase upon read-in. Each line follows similar syntax which uses the first non-blank space character as identifier. Each identifier tells JoSIM how to handle that specific line. Identifiers that start with a letter relate to physical components in the design, e.g. L, C, R. Lines of this kind almost always follows the same syntax in that it requires a label and two nodes. These nodes can be alphanumeric with the restriction of 0 and GND which indicate a grounded node. Additionally, the use of period ( . ) or vertical bars ( | ) in label or node names are prohibited as these are reserved characters within JoSIM. Lines that start with a period ( . ) indicate that the line relates in some way to simulation control. In this case whatever follows the period identifies the control, e.g. .tran, .print, .end. Comments are lines that start with an asterisk ( * ) or a pound sign ( # ). Comments are meant to be in a line of their own and will not work if placed at the end of a line. Lines that end with a plus sign ( + ) indicate that the line that follows is a continuation of this line. Internally the two lines will be combined. In most cases the VALUE of a component can be replaced by a variable name or an expression. Variables can be defined using the .PARAM control and expressions can be evaluated by encapsulating the expression in braces ( {} ). These will be discussed in detail further. Values in JoSIM can be modified with engineering notation or through suffixes. A list of the available suffixes is found below: Suffix Meaning Engineering Notation Equivalent F Femto 1E-15 P Pico 1E-12 N Nano 1E-9 U Micro 1E-6 M Milli 1E-3 K Kilo 1E3 MEG Mega 1E6 X G Giga 1E9 T Terra 1E12 We will now run through all the available physical components and their limitations. Any parameter surrounded by square brackets are optional and nested square brackets mean that the encapsulated parameter relies on the existance of the previous.","title":"Syntax"},{"location":"syntax/#basic-components","text":"","title":"Basic Components"},{"location":"syntax/#resistor","text":"R Label PosNode NegNode VALUE The value of a resistor is in Ohms.","title":"Resistor"},{"location":"syntax/#inductor","text":"L Label PosNode NegNode VALUE The value of an inductor is in Henry.","title":"Inductor"},{"location":"syntax/#capacitor","text":"C Label PosNode NegNode VALUE The value of a capacitor is in Farad.","title":"Capacitor"},{"location":"syntax/#josephson-junction-jj","text":"B Label PosNode NegNode <PhaseNode> MODEL [< AREA >] A Josephson junction is a two terminal device but could also be defined with a third non-connected node to allow compatibility with WRspice. This node is not used in any way in JoSIM. The Josephson junction requires specification of a model name which can be defined anyware in the program using the control .MODEL . This model control has the following syntax .MODEL ModelName ModelType ([ MODEL PARAMETERS ]) The only junction model currently supported by JoSIM is the RCSJ model and thus the only available ModelType is jj with the following tunable parameters: Parameter Range Default Description RTYPE 0, 1 1 Linearisation model used VG or VGAP -\\(\\infty\\), \\(\\infty\\) 2.8E-3 Junction gap voltage IC or ICRIT -\\(\\infty\\), \\(\\infty\\) 1E-3 Junction critical current RN 0, \\(\\infty\\) 5 Junction normal resistance R0 0, \\(\\infty\\) 30 Junction subgap resistance C or CAP 0, \\(\\infty\\) 2.5E-12 Junction capacitance T 0, \\(\\infty\\) 4.2 Boiling point of liquid coolant TC 0, \\(\\infty\\) 9.1 Critical temperature of superconducting material DELV 0, \\(\\infty\\) 0.1E-3 Transitional voltage from subgap to normal D 0.0, 1 0.0 Point contact transparency affecting current phase relationship ICFCT or ICFACT 0, 1 \\(\\pi\\)/4 Ratio of critical current to quasiparticle step height PHI 0, n\\(\\pi\\) 0 Starting phase for junction The .model line is unique to the subcircuit it falls under and can thus allow different models with the same name under seperate subcircuits. If the model is not found under the subcircuit it will be searched for globally and if not found default values (default model) will be used instead.","title":"Josephson Junction (JJ)"},{"location":"syntax/#transmission-line","text":"T Label PosNode1 NegNode1 PosNode2 NegNode2 TD=VALUE Z0=VALUE TD is the time delay in pico seconds. Z0 is the impedance in Ohms.","title":"Transmission Line"},{"location":"syntax/#mutual-inductance","text":"K Label Inductor1 Inductor2 VALUE The value is the coupling factor k .","title":"Mutual Inductance"},{"location":"syntax/#sources","text":"","title":"Sources"},{"location":"syntax/#voltage-source","text":"V Label PosNode NegNode SOURCETYPE","title":"Voltage Source"},{"location":"syntax/#current-source","text":"I Label PosNode NegNode SOURCETYPE","title":"Current Source"},{"location":"syntax/#phase-source","text":"P Label PosNode NegNode SOURCETYPE","title":"Phase Source"},{"location":"syntax/#source-types","text":"","title":"Source Types"},{"location":"syntax/#piece-wise-linear-pwl","text":"pwl(0 0 Time1 Amplitude1 ... TimeN AmplitudeN ) This source linearly interpolates amplitude values for every time point in the simulation between the specified amplitudes. The initial two values are required to be zero at the start of the simulation.","title":"Piece Wise Linear (PWL)"},{"location":"syntax/#pulse","text":"pulse( A_1 A_2 [ T_D [ T_R [ T_F [ PW [ PER ]]]]] ) This source generates a pulse between two amplitudes ( A_1 & A_2 ), starts after T_D and has a rise and fall time ( T_R & T_F ), which default to the transient simulation step size. PW and PER refer to the pulse width and the period respectivrespectively. These values default to the transient simulation stop time when not specified. This source allows the continuous generation of a pulse at a set frequency.","title":"Pulse"},{"location":"syntax/#sinusoidal","text":"sin( \b A_O A [ FREQ [ T_D [ THETA ]]] ) A source that generates a sinusoidal signal with A_O offset and A amplitude at a frequency of FREQ which defaults to 1/(Transient simulation stop time). T_D sets the stop time and THETA modulates the signal amplitude. The function generates a data point for each step in the transient simulation based on the following equation: f(t) = A_O + A\\sin (2\\pi FREQ(t-T_D))e^{-THETA(t-T_D)}","title":"Sinusoidal"},{"location":"syntax/#custom-waveform","text":"cus( wavefile T_S SF IM [ T_D PER] ) This source allows the generates a function based on the points inside the plain text wave file. This file should contain a single line of space seperated numbers. E.g 0 2 3 6 2 1 0 Each number in this line represents an amplitude seperated by time step T_S and scaled using scale factor SF . The values between the points are interpolated using either no interpolation (0), linear (1), cubic (2) or spline (3). The function can become periodic if PER is set to 1, whereby the pattern is repeated for the entire simulation.","title":"Custom Waveform"},{"location":"syntax/#control-commands","text":"The simulation engine requires control commands to know what to do with the components it has just been provided with. The most important of these control commands is the transient simulation command as no simulation can be performed without it.","title":"Control Commands"},{"location":"syntax/#simulation","text":".tran T_{step} T_{stop} [ T_{start} ] This generates a simulation that runs from T_{start} (0 unless specified) until T_{stop} and generates a simulation point at every T_{step} between those two points. The difference between start and stop divided by the step size floored to the closest integer value indicates how many simulation steps there will be. JoSIM does not at present support any form of variable timestep input. It will in addition complain if a timestep is chosen that results in a phase step larger than 20% of 2 \\pi .","title":"Simulation"},{"location":"syntax/#output","text":"A simulation is meaningless unless the results are stored or viewed in some way. In order to know which of these results are relevant and need to be stored the simulator needs output control commands. These output commands can be of either .print .plot .save Any of these commands can be followed by either of the following commands PrintType Device or Node PType(Device or Node) _0 ... PType(Device or Node) _n Where PrintType can be either device voltage ( DEVV ), device current ( DEVI ), device phase ( PHASE ), node voltage ( NODEV ) or node phase ( NODEP ). When specifying a device type store only a single device can be specified, but when a node type store is specified 2 nodes can be specified to store the difference between them. PType is shorthand for the above and can have multiple per line requests. PType can be either of V , I (or C ) or P followed by the device or node in brackets. If more than one device or node is specified by comma seperation (maximum 2) the difference between the two devices or nodes is stored. An additional save type exists that has the following syntax @ Device [ PType ] This stores the PType of the device specified.","title":"Output"},{"location":"syntax/#subcircuits","text":"Subcircuits allow subdivision and reuse of smaller circuits within a larger design. When wrapped in a subcircuit control devices are allowed to have the same label names as specified elsewhere in the netlist as the subcircuit completely isolates them. Subcircuits have the following wrapping control syntax .subckt SubcktName IO Nodes ... .ends The SubcktName specifies the name of the subcircuit and IO Nodes specify the which nodes within the subcircuit connects to outside. A subcircuit can be used in the main netlist or another subcircuit (nesting) using the following syntax X Label SubcktName IO Nodes (JSIM mode) X Label IO Nodes SubcktName (WRspice (normal SPICE) mode) Additional features of the subcircuit include isolation of parameters (discussed next) and the ability to plot/print the devices or nodes within a subcircuit by specifying the device or node followed by either a . or a | and then the XLabel . i.e. .print v(14.X01) p(B01.X02) Subcircuits as mentioned before can also be nested almost indefinitely as they are expanded upon simulation.","title":"Subcircuits"},{"location":"syntax/#parameters","text":"The final control command that is of importance in JoSIM is the parameters command with the following syntax .param VarName = Expression VarName is the variable name that can be used anywhere else in the circuit and Expression is a mathematical expression that is evaluated using an implementation of Dijkstra's shunting yard algorithm, whereby the expression is converted into reverse polish notation (RPN) and evaluated. Additionally, expressions can also contain other variables and parameters will be continuosly evaluated untill all variables are reduced to values. If variables are not defined the program will halt and produce an error.","title":"Parameters"},{"location":"syntax/#control-block","text":"Any of the above controls can be wrapped inside a control block with the following syntax .control ... .endc Wherein all controls can be specified by omitting the usual prepending period to the command.","title":"Control Block"},{"location":"syntax/#include","text":"JoSIM allows the use of a .include control card that uses the following syntax .include relative_path_to_file This command reads in the contents of the relevant file pointed to by the relevant path uppon parsing of the netlist essentially extending the netlist by the linked file. This is incredibly handy when large subcircuits are involved and reuse of subcircuits accross multiple files is required. This can also be used to house all the models used in simulation allowing a central point of alteration if the model is changed.","title":"Include"},{"location":"syntax/#standard-input","text":"JoSIM now allows input from standard input allowing a line-by-line read in of a netlist until the .end card is found or alternatively the EOF character is returned.","title":"Standard Input"},{"location":"tech_disc/","text":"Technical Discussion Modified nodal analysis There are many ways to setup a set of linear equations to solve the voltage or currents in a circuit. One of the more well known ways is to use nodal analysis which creates an equation for each node defined in the circuit netlist. This method is the basis on which the original Berkeley SPICE[ spice ] was built. This method, however, only calculates the voltages of every node which makes it difficult to handle components that are voltage dependent such as inductors and junctions. This drawback lead to the creation of the modified nodal analysis which is an extension to the prior with the ability to calculating branch currents in addition to nodal voltages[ mna ]. We therefore make use of the MNA method to build the set of linear equations within JoSIM due to the large use of inductors as well as Josephson junctions in superconductivity. A useful feature of the MNA method allows every component to be represented as a sub-matrix called a stamp. The summation of all the stamps provide us with the A , x as well as b matrices that are required to solve the linear equations. These stamps will be discussed further in the following subsection. Trapezoidal integration. The trapezoidal method for solving linear equations is a second order method for which the solution accuracy improves by reducing the time step size. We can express the trapezoidal method as: \\left( \\frac{dx}{dt}\\right) _{n}=\\frac{2}{h_{n}}\\left( x_{n} - x_{n-1} \\right) - \\left(\\frac{dx}{dt} \\right) _{n-1} In this case n is the current time step and n-1\u200b refers to the previous time step. By using this method to solve differential equations we are able to create generic stamps for each component that JoSIM can handle. To demonstrate this method and how a stamp is formed we will show an example of an inductor. Fig. 1 - A basic inductor with current flowing through it The inductor in Fig. 1 has a general equation to determine the voltage across it as: v_{L1}(t) = L1\\frac{di}{dt} When we apply the trapezoidal rule we find that this equation can be rewritten as: \\begin{align} v_{n} &= L1 \\left[ \\frac{2}{h_n} \\left( I_{n} - I_{n-1} \\right) - \\left( \\frac{di}{dt}\\right)_{n-1} \\right] \\\\ & = \\frac{2L1}{h_n} \\left( I_{n} - I_{n-1} \\right) - L1 \\left( \\frac{di}{dt}\\right)_{n-1} \\\\ & = \\frac{2L1}{h_n} \\left( I_{n} - I_{n-1} \\right) - v_{n-1} \\\\ \\therefore I_{n} & = \\frac{h_{n}}{2L1} \\left( V_{n} + V_{n-1}\\right) + I_{n-1} \\\\ \\therefore \\frac{h_{n}}{2L1}V_{n} - I_{n} & = -\\frac{h_{n}}{2L1}V_{n-1} + I_{n-1} \\end{align} Where the above is the current step voltage and current as a function of the previous step values. We further expand this equation by stating that the voltage is the potential across the two nodes: v = v_{1} - v_{2} . \\begin{equation} \\frac{h_{n}}{2L1}(V_{1})_{n} - \\frac{h_{n}}{2L1}(V_{2})_{n} - I_{n} = -\\left( \\frac{h_{n}}{2L1}V(V_{1})_{n-1} - \\frac{h_{n}}{2L1}(V_{2})_{n-1}\\right) - I_{n-1} \\end{equation} Which we can then write in matrix form as: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & \\frac{-2L1}{h_n} \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\\\ I_{L1} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -\\frac{2L1}{h_{n}}(I_{L1})_{n-1} - \\left( (V_{1})_{n-1} - (V_{2})_{n-1}\\right) \\end{bmatrix} \\end{equation} The matrix above is a generic stamp that we can place into the A matrix which describes the inductor L1. We can do the same for a resistor, capacitor, current source, voltage source, Josephson junction and a transmission line. The stamps for each of these components can be found in the Component Stamps section. Gear Integration Similar to the trapezoidal method, the Gear method or BDF2 (backward differentiation formulae) is also a second order integration method. This method, however, is better known as a linear multistep method and is the most stable second order integration method. This method is expressed as: \\left(\\frac{dx}{dt}\\right)_n = \\frac{3}{2h}\\left[x_n - \\frac{4}{3}x_{n-1} + \\frac{1}{3}x_{n\u22122}\\right] This method requires knowledge of at least 2 prior timesteps, indicated by n-1 and n-2 . Though this method might seem like it requires extra computation for every component, it actually simplifies components that require differentials. We demonstrate this using the capacitor. Fig. 2 - A basic capacitor with current flowing through it The capactor in Fig. 2 has a general equation to determine the current through it as: i_{C1}(t) = C1\\frac{dv}{dt} When we apply the Gear method to find that this equation can be rewritten as: \\begin{align} i_{n} &= C1 \\frac{3}{2h} \\left[ v_n -\\frac{4}{3}v_{n-1}+\\frac{1}{3}v_{n-2}\\right] \\\\ & = \\frac{3C1}{2h} V_n - \\frac{2C1}{h}V_{n-1}+\\frac{C1}{2h}V_{n-2}\\ \\\\ \\therefore \\frac{3C1}{2h} V_n - I_{n} & = \\frac{2C1}{h}V_{n-1}-\\frac{C1}{2h}V_{n-2} \\end{align} or rather V_n - \\frac{2h}{3C1}I_n = \\frac{4}{3}V_{n-1}-\\frac{1}{3}V_{n-2} Which we can then write in matrix form as: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{2h}{3C1} \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\\\ I_{C1} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{4}{3}V_{n-1}-\\frac{1}{3}V_{n-2} \\end{bmatrix} \\end{equation} The matrix above is a generic stamp that we can place into the A matrix which describes the capacitor C1. The extension that will allow JoSIM to use Gear method is available in v2.5 (testing) at time of writing. Modified nodal phase analysis First introduced in version 2.0 of JoSIM, the ability to perform a simulation that calculates the nodal phase instead of voltage is presented. This new analysis method is named the modified nodal phase analysis (MNPA) and utilizes the voltage-phase [ orlando ] relationship seen below. \\begin{equation} v = \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt} \\end{equation} If this relationship is applied to all the component models found in JoSIM we obtain the MNPA stamps, which allow us to solve the phase directly. As example we demonstrate this on the inductor equation shown in the previous section. \\begin{align} \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt} &= L1\\frac{di}{dt} \\\\ \\frac{\\Phi_{0}}{2\\pi}\\phi_{n} &= L1 I_{n} \\\\ \\frac{\\Phi_{0}}{2\\pi L1}\\phi_{n}^{+} - \\frac{\\Phi_{0}}{2\\pi L1}\\phi_{n}^{-}&= I_{n} \\end{align} The above is functionally equivalent to the resistor in voltage analysis. The computation required to solve the phase of an inductor is therefore far less complex than that of solving the voltage. With superconducting circuits being largely inductive, the use of phase reduces the overall complexity of the solution which in turn provides faster simulations and reduced memory usage. JoSIM has been adapted to allow phase analysis on any design that works with voltage analysis without requiring alterations to the netlist file. Since the voltage is simply the scaled time derivative of the phase the voltage can be calculated as a post process if the user requests it. Phase mode simulation can be enabled using the command line switch -a followed by a 1 . If not provided the default for this command is 0 , which indicates a voltage mode simulation will be performed. All the MNPA stamps are included in the Component Stamps section. LU decomposition When the A matrix has been set up as detailed in the previous section all that is left to do is to solve the Ax=b\u200b problem using some form of iterative method. We choose KLU from the SuiteSparse[ suitesparse ] library to accomplish this task. This requires the A matrix to be in compressed row storage (CRS)[ crs ] format which is a data structure of 3 vectors. The first of these vectors contains all the non-zero elements in the A matrix. The second contains an initial zero followed by the total number of non-zero elements at the end of each row such that the final entry in the vector is the total number of non-zero elements. The third vector contains the column index of each non-zero element. As an example, the following sparse 5x5 matrix: \\begin{equation} \\begin{bmatrix} 1 & 0 & 0 & 4 & 0\\\\ 0 & 3 & 2 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0\\\\ 0& 4 & 0 & 5 & 0 \\\\ 0 & 0 & 0 & 0 & 1 \\end{bmatrix} \\end{equation} would yield a CSR format data structure of \\begin{align} nnz & = \\left[ 1, 4, 3, 2, 1, 4, 5, 1 \\right] \\\\ rowptr & = \\left[ 0, 2, 4, 5, 7, 8 \\right] \\\\ colind & = \\left[ 0, 3, 1, 2, 2, 1, 3, 4 \\right] \\end{align} which has a total of 21 elements compared to the 25 required for the original A matrix. This difference, ofcourse, becomes much greater as the A matrix grows in size as well as the sparser the matrix becomes, which is almost always the case for electrical type simulations. Once in this format we can proceed with the KLU factorization. Due to the MNA forcing only the RHS to change upon every time step, we only have to compute the LU decomposition for the A matrix once at the start of the time loop. With this single calculation of the LU decomposition done, the only calculation required is the solving of x (LHS) upon each iteration using the ever changing b (RHS). Data structures & speed considerations JoSIM relies heavily on the use of the C++ map data structure which creates a hash table for quick lookup. This immensely simplifies code legibility as well as component identification within later stages of the process. The drawback of this, however, is the hashing and comparing becomes quite slow when using string types. Initially a standard map was used, however, this very negatively impacted the execution speed of the program and thus alternatives were sought. These ordered map (standard maps) were replaced by the much faster unordered map since the map no longer needed to be sorted by keys upon each new entry. Ideally the use of unordered maps are not perfect if speed was the only consideration. They do, however, provide a good balance between implementation, speed and debugging. To avoid some of the speed problems, a string map is only used initially to create components, mapping component labels to integer indices. During the simulation step only the indices are used. The results are then mapped back to the string equivalents to find the relevant output vectors requested by the user. Additional steps have been implemented to reduce the required memory for the result vectors. This is achieved by idenitifying which vectors are required to produce the relevant output prior to simulation. During simulation only these required vectors are then populated with values as opposed to storing all calculated values. This drastically reduces the required memory. Through the implementation of the MNPA method in JoSIM, additional improvements were introduced such as the objectification of every component at the matrix creation level that increases efficiency and debugging. This change allows for simplification of output functions since a direct link to the rows of the result matrix for each component reduces the indexing time required to identify the correct row. Input Files Input files for JoSIM are called netlists and follow mostly a standard SPICE syntax as described in [ spice ]. There are, however, many functions and components of this syntax that have not been implemented since they are only of relevance to semiconductor circuits. A full syntax guideline is avalable in the Syntax section. There are a few caviates to making JoSIM compatible with other netlist generating systems. Most of these can be ironed out through routines within the code itself to make the simulator as accepting as possible. One of these caviates, however, requires user input and this is to identify the convention used when simulating using subcircuits. When a netlist with subcircuits is generated to be JSIM[ jsim ] compatible, a subcircuit line would for example be: X01 SUBNAME 1 2 This indicates that a subcircuit of name SUBNAME is to be used with I/O nodes 1 and 2. This we call convention 0 and is the default for JoSIM. If a circuit is generated for compatibility with WRspice[ wrspice ] then this convention would be 1 and an example of a subcircuit line would be: X01 1 2 SUBNAME This is the general SPICE syntax convention and in all honesty makes more sense since a component definition line should always carry the notation: LABEL POSNODE NEGNODE It is required that the user specify the convention when working with a non JSIM netlist. The convention can be set using the -c command line switch followed by the convention required. Output Files As stated before, JoSIM is a simulator that solves Ax=b problems. As a result the output that JoSIM provides to the user is always that of the x vector. At present JoSIM only does a transient analysis, which means that each entry of the x vector contains another vector of result values for each time step in the transient analysis. When the user does not request any output, and does not specify a file within which to save the results, all of the results for the entire x vector are dumped to the screen in a space seperated way. This can be resource intensive and does not mean much to the user. It is therefore advisable to always specify the vectors of interest using the output commands specfied in Syntax as well as a resulting file to store the output in. The output file can be either a comma seperated variable ( .csv ) file or a space seperated ( .dat ) file. The the type and name of the output file are specified using the -o command switch followed by the file name. The file extension determines the type. There is a third option of output format which follows the standard SPICE RAW data syntax. This format is compatible with various output trace viewers and can be specified by simply ommiting the file extension of in the output name. Plotting interfaces In previous versions of JoSIM there existed 2 plotting windows, namely FLTK and Matplotlib. These interfaces were, however, ultimately scrapped due to maintainability issues as well as cross-platform compatibility. The user is requested to use the plotting system they are most comfortable with. Below we provide a simple Python 3 script that plots all the results in a .csv file. It is very basic and the user should modify it as required. This script requires installation of the Numpy as well as Matplotlib packages for Python 3. Optionally, we comment the lines for use of the Qt5 backend for plotting. The user can enable this if the PyQt5 package is installed. #!/usr/bin/env python import math # import matplotlib # matplotlib.use('Qt5Agg') import matplotlib.pyplot as pl from matplotlib import gridspec import numpy as np import csv import sys time = [] data = [] labels = set() with open(sys.argv[1], 'r') as csvFile: reader = csv.DictReader(csvFile) labels = reader.fieldnames data.append([]) for row in reader: time.append(float(row[labels[0]])) for var in range(1,len(labels)): data.append([]) data[var].append(float(row[labels[var]])) csvFile.close() N = len(labels) - 1 cols = int(math.ceil(N / 4)) rows = int(math.ceil(N / cols)) gs = gridspec.GridSpec(rows, cols) fig = pl.figure() for var in range(1,len(labels)): ax = fig.add_subplot(gs[var - 1]) ax.plot(time, data[var]) ax.set_xlabel(labels[0]) ax.set_ylabel(labels[var]) fig.set_tight_layout(True) fig.show() input() .center { display: block; margin: 0 auto; } spice Nagel L.: Spice: A computer program to simulate computer circuits . University of California, Berkeley UCB/ERL Memo M520. (1995) mna Ho C., Ruehli A., Brennan P.: The modified nodal approach to network analysis . IEEE Transactions on circuits and systems. 22 , (1975) orlando Orlando T.P., Delin K.A.: Foundations of applied superconductivity . (1991) suitesparse Davis T.A.: Direct methods for sparse linear systems . (2006) crs Bulu jsim Fang E.S.: A Josephson integrated circuit simulator (JSIM) for superconductive electronics application . (1989) wrspice Simulator W.C.: Whiteley Research Incorporated . (2017)","title":"Technical Discussion"},{"location":"tech_disc/#technical-discussion","text":"","title":"Technical Discussion"},{"location":"tech_disc/#modified-nodal-analysis","text":"There are many ways to setup a set of linear equations to solve the voltage or currents in a circuit. One of the more well known ways is to use nodal analysis which creates an equation for each node defined in the circuit netlist. This method is the basis on which the original Berkeley SPICE[ spice ] was built. This method, however, only calculates the voltages of every node which makes it difficult to handle components that are voltage dependent such as inductors and junctions. This drawback lead to the creation of the modified nodal analysis which is an extension to the prior with the ability to calculating branch currents in addition to nodal voltages[ mna ]. We therefore make use of the MNA method to build the set of linear equations within JoSIM due to the large use of inductors as well as Josephson junctions in superconductivity. A useful feature of the MNA method allows every component to be represented as a sub-matrix called a stamp. The summation of all the stamps provide us with the A , x as well as b matrices that are required to solve the linear equations. These stamps will be discussed further in the following subsection.","title":"Modified nodal analysis"},{"location":"tech_disc/#trapezoidal-integration","text":"The trapezoidal method for solving linear equations is a second order method for which the solution accuracy improves by reducing the time step size. We can express the trapezoidal method as: \\left( \\frac{dx}{dt}\\right) _{n}=\\frac{2}{h_{n}}\\left( x_{n} - x_{n-1} \\right) - \\left(\\frac{dx}{dt} \\right) _{n-1} In this case n is the current time step and n-1\u200b refers to the previous time step. By using this method to solve differential equations we are able to create generic stamps for each component that JoSIM can handle. To demonstrate this method and how a stamp is formed we will show an example of an inductor. Fig. 1 - A basic inductor with current flowing through it The inductor in Fig. 1 has a general equation to determine the voltage across it as: v_{L1}(t) = L1\\frac{di}{dt} When we apply the trapezoidal rule we find that this equation can be rewritten as: \\begin{align} v_{n} &= L1 \\left[ \\frac{2}{h_n} \\left( I_{n} - I_{n-1} \\right) - \\left( \\frac{di}{dt}\\right)_{n-1} \\right] \\\\ & = \\frac{2L1}{h_n} \\left( I_{n} - I_{n-1} \\right) - L1 \\left( \\frac{di}{dt}\\right)_{n-1} \\\\ & = \\frac{2L1}{h_n} \\left( I_{n} - I_{n-1} \\right) - v_{n-1} \\\\ \\therefore I_{n} & = \\frac{h_{n}}{2L1} \\left( V_{n} + V_{n-1}\\right) + I_{n-1} \\\\ \\therefore \\frac{h_{n}}{2L1}V_{n} - I_{n} & = -\\frac{h_{n}}{2L1}V_{n-1} + I_{n-1} \\end{align} Where the above is the current step voltage and current as a function of the previous step values. We further expand this equation by stating that the voltage is the potential across the two nodes: v = v_{1} - v_{2} . \\begin{equation} \\frac{h_{n}}{2L1}(V_{1})_{n} - \\frac{h_{n}}{2L1}(V_{2})_{n} - I_{n} = -\\left( \\frac{h_{n}}{2L1}V(V_{1})_{n-1} - \\frac{h_{n}}{2L1}(V_{2})_{n-1}\\right) - I_{n-1} \\end{equation} Which we can then write in matrix form as: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & \\frac{-2L1}{h_n} \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\\\ I_{L1} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -\\frac{2L1}{h_{n}}(I_{L1})_{n-1} - \\left( (V_{1})_{n-1} - (V_{2})_{n-1}\\right) \\end{bmatrix} \\end{equation} The matrix above is a generic stamp that we can place into the A matrix which describes the inductor L1. We can do the same for a resistor, capacitor, current source, voltage source, Josephson junction and a transmission line. The stamps for each of these components can be found in the Component Stamps section.","title":"Trapezoidal integration."},{"location":"tech_disc/#gear-integration","text":"Similar to the trapezoidal method, the Gear method or BDF2 (backward differentiation formulae) is also a second order integration method. This method, however, is better known as a linear multistep method and is the most stable second order integration method. This method is expressed as: \\left(\\frac{dx}{dt}\\right)_n = \\frac{3}{2h}\\left[x_n - \\frac{4}{3}x_{n-1} + \\frac{1}{3}x_{n\u22122}\\right] This method requires knowledge of at least 2 prior timesteps, indicated by n-1 and n-2 . Though this method might seem like it requires extra computation for every component, it actually simplifies components that require differentials. We demonstrate this using the capacitor. Fig. 2 - A basic capacitor with current flowing through it The capactor in Fig. 2 has a general equation to determine the current through it as: i_{C1}(t) = C1\\frac{dv}{dt} When we apply the Gear method to find that this equation can be rewritten as: \\begin{align} i_{n} &= C1 \\frac{3}{2h} \\left[ v_n -\\frac{4}{3}v_{n-1}+\\frac{1}{3}v_{n-2}\\right] \\\\ & = \\frac{3C1}{2h} V_n - \\frac{2C1}{h}V_{n-1}+\\frac{C1}{2h}V_{n-2}\\ \\\\ \\therefore \\frac{3C1}{2h} V_n - I_{n} & = \\frac{2C1}{h}V_{n-1}-\\frac{C1}{2h}V_{n-2} \\end{align} or rather V_n - \\frac{2h}{3C1}I_n = \\frac{4}{3}V_{n-1}-\\frac{1}{3}V_{n-2} Which we can then write in matrix form as: \\begin{equation} \\begin{bmatrix} 0 & 0 & 1 \\\\ 0 & 0 & -1 \\\\ 1 & -1 & - \\frac{2h}{3C1} \\end{bmatrix} \\begin{bmatrix} V_{1} \\\\ V_{2} \\\\ I_{C1} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{4}{3}V_{n-1}-\\frac{1}{3}V_{n-2} \\end{bmatrix} \\end{equation} The matrix above is a generic stamp that we can place into the A matrix which describes the capacitor C1. The extension that will allow JoSIM to use Gear method is available in v2.5 (testing) at time of writing.","title":"Gear Integration"},{"location":"tech_disc/#modified-nodal-phase-analysis","text":"First introduced in version 2.0 of JoSIM, the ability to perform a simulation that calculates the nodal phase instead of voltage is presented. This new analysis method is named the modified nodal phase analysis (MNPA) and utilizes the voltage-phase [ orlando ] relationship seen below. \\begin{equation} v = \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt} \\end{equation} If this relationship is applied to all the component models found in JoSIM we obtain the MNPA stamps, which allow us to solve the phase directly. As example we demonstrate this on the inductor equation shown in the previous section. \\begin{align} \\frac{\\Phi_{0}}{2\\pi}\\frac{d\\phi}{dt} &= L1\\frac{di}{dt} \\\\ \\frac{\\Phi_{0}}{2\\pi}\\phi_{n} &= L1 I_{n} \\\\ \\frac{\\Phi_{0}}{2\\pi L1}\\phi_{n}^{+} - \\frac{\\Phi_{0}}{2\\pi L1}\\phi_{n}^{-}&= I_{n} \\end{align} The above is functionally equivalent to the resistor in voltage analysis. The computation required to solve the phase of an inductor is therefore far less complex than that of solving the voltage. With superconducting circuits being largely inductive, the use of phase reduces the overall complexity of the solution which in turn provides faster simulations and reduced memory usage. JoSIM has been adapted to allow phase analysis on any design that works with voltage analysis without requiring alterations to the netlist file. Since the voltage is simply the scaled time derivative of the phase the voltage can be calculated as a post process if the user requests it. Phase mode simulation can be enabled using the command line switch -a followed by a 1 . If not provided the default for this command is 0 , which indicates a voltage mode simulation will be performed. All the MNPA stamps are included in the Component Stamps section.","title":"Modified nodal phase analysis"},{"location":"tech_disc/#lu-decomposition","text":"When the A matrix has been set up as detailed in the previous section all that is left to do is to solve the Ax=b\u200b problem using some form of iterative method. We choose KLU from the SuiteSparse[ suitesparse ] library to accomplish this task. This requires the A matrix to be in compressed row storage (CRS)[ crs ] format which is a data structure of 3 vectors. The first of these vectors contains all the non-zero elements in the A matrix. The second contains an initial zero followed by the total number of non-zero elements at the end of each row such that the final entry in the vector is the total number of non-zero elements. The third vector contains the column index of each non-zero element. As an example, the following sparse 5x5 matrix: \\begin{equation} \\begin{bmatrix} 1 & 0 & 0 & 4 & 0\\\\ 0 & 3 & 2 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0\\\\ 0& 4 & 0 & 5 & 0 \\\\ 0 & 0 & 0 & 0 & 1 \\end{bmatrix} \\end{equation} would yield a CSR format data structure of \\begin{align} nnz & = \\left[ 1, 4, 3, 2, 1, 4, 5, 1 \\right] \\\\ rowptr & = \\left[ 0, 2, 4, 5, 7, 8 \\right] \\\\ colind & = \\left[ 0, 3, 1, 2, 2, 1, 3, 4 \\right] \\end{align} which has a total of 21 elements compared to the 25 required for the original A matrix. This difference, ofcourse, becomes much greater as the A matrix grows in size as well as the sparser the matrix becomes, which is almost always the case for electrical type simulations. Once in this format we can proceed with the KLU factorization. Due to the MNA forcing only the RHS to change upon every time step, we only have to compute the LU decomposition for the A matrix once at the start of the time loop. With this single calculation of the LU decomposition done, the only calculation required is the solving of x (LHS) upon each iteration using the ever changing b (RHS).","title":"LU decomposition"},{"location":"tech_disc/#data-structures-speed-considerations","text":"JoSIM relies heavily on the use of the C++ map data structure which creates a hash table for quick lookup. This immensely simplifies code legibility as well as component identification within later stages of the process. The drawback of this, however, is the hashing and comparing becomes quite slow when using string types. Initially a standard map was used, however, this very negatively impacted the execution speed of the program and thus alternatives were sought. These ordered map (standard maps) were replaced by the much faster unordered map since the map no longer needed to be sorted by keys upon each new entry. Ideally the use of unordered maps are not perfect if speed was the only consideration. They do, however, provide a good balance between implementation, speed and debugging. To avoid some of the speed problems, a string map is only used initially to create components, mapping component labels to integer indices. During the simulation step only the indices are used. The results are then mapped back to the string equivalents to find the relevant output vectors requested by the user. Additional steps have been implemented to reduce the required memory for the result vectors. This is achieved by idenitifying which vectors are required to produce the relevant output prior to simulation. During simulation only these required vectors are then populated with values as opposed to storing all calculated values. This drastically reduces the required memory. Through the implementation of the MNPA method in JoSIM, additional improvements were introduced such as the objectification of every component at the matrix creation level that increases efficiency and debugging. This change allows for simplification of output functions since a direct link to the rows of the result matrix for each component reduces the indexing time required to identify the correct row.","title":"Data structures &amp; speed considerations"},{"location":"tech_disc/#input-files","text":"Input files for JoSIM are called netlists and follow mostly a standard SPICE syntax as described in [ spice ]. There are, however, many functions and components of this syntax that have not been implemented since they are only of relevance to semiconductor circuits. A full syntax guideline is avalable in the Syntax section. There are a few caviates to making JoSIM compatible with other netlist generating systems. Most of these can be ironed out through routines within the code itself to make the simulator as accepting as possible. One of these caviates, however, requires user input and this is to identify the convention used when simulating using subcircuits. When a netlist with subcircuits is generated to be JSIM[ jsim ] compatible, a subcircuit line would for example be: X01 SUBNAME 1 2 This indicates that a subcircuit of name SUBNAME is to be used with I/O nodes 1 and 2. This we call convention 0 and is the default for JoSIM. If a circuit is generated for compatibility with WRspice[ wrspice ] then this convention would be 1 and an example of a subcircuit line would be: X01 1 2 SUBNAME This is the general SPICE syntax convention and in all honesty makes more sense since a component definition line should always carry the notation: LABEL POSNODE NEGNODE It is required that the user specify the convention when working with a non JSIM netlist. The convention can be set using the -c command line switch followed by the convention required.","title":"Input Files"},{"location":"tech_disc/#output-files","text":"As stated before, JoSIM is a simulator that solves Ax=b problems. As a result the output that JoSIM provides to the user is always that of the x vector. At present JoSIM only does a transient analysis, which means that each entry of the x vector contains another vector of result values for each time step in the transient analysis. When the user does not request any output, and does not specify a file within which to save the results, all of the results for the entire x vector are dumped to the screen in a space seperated way. This can be resource intensive and does not mean much to the user. It is therefore advisable to always specify the vectors of interest using the output commands specfied in Syntax as well as a resulting file to store the output in. The output file can be either a comma seperated variable ( .csv ) file or a space seperated ( .dat ) file. The the type and name of the output file are specified using the -o command switch followed by the file name. The file extension determines the type. There is a third option of output format which follows the standard SPICE RAW data syntax. This format is compatible with various output trace viewers and can be specified by simply ommiting the file extension of in the output name.","title":"Output Files"},{"location":"tech_disc/#plotting-interfaces","text":"In previous versions of JoSIM there existed 2 plotting windows, namely FLTK and Matplotlib. These interfaces were, however, ultimately scrapped due to maintainability issues as well as cross-platform compatibility. The user is requested to use the plotting system they are most comfortable with. Below we provide a simple Python 3 script that plots all the results in a .csv file. It is very basic and the user should modify it as required. This script requires installation of the Numpy as well as Matplotlib packages for Python 3. Optionally, we comment the lines for use of the Qt5 backend for plotting. The user can enable this if the PyQt5 package is installed. #!/usr/bin/env python import math # import matplotlib # matplotlib.use('Qt5Agg') import matplotlib.pyplot as pl from matplotlib import gridspec import numpy as np import csv import sys time = [] data = [] labels = set() with open(sys.argv[1], 'r') as csvFile: reader = csv.DictReader(csvFile) labels = reader.fieldnames data.append([]) for row in reader: time.append(float(row[labels[0]])) for var in range(1,len(labels)): data.append([]) data[var].append(float(row[labels[var]])) csvFile.close() N = len(labels) - 1 cols = int(math.ceil(N / 4)) rows = int(math.ceil(N / cols)) gs = gridspec.GridSpec(rows, cols) fig = pl.figure() for var in range(1,len(labels)): ax = fig.add_subplot(gs[var - 1]) ax.plot(time, data[var]) ax.set_xlabel(labels[0]) ax.set_ylabel(labels[var]) fig.set_tight_layout(True) fig.show() input() .center { display: block; margin: 0 auto; } spice Nagel L.: Spice: A computer program to simulate computer circuits . University of California, Berkeley UCB/ERL Memo M520. (1995) mna Ho C., Ruehli A., Brennan P.: The modified nodal approach to network analysis . IEEE Transactions on circuits and systems. 22 , (1975) orlando Orlando T.P., Delin K.A.: Foundations of applied superconductivity . (1991) suitesparse Davis T.A.: Direct methods for sparse linear systems . (2006) crs Bulu jsim Fang E.S.: A Josephson integrated circuit simulator (JSIM) for superconductive electronics application . (1989) wrspice Simulator W.C.: Whiteley Research Incorporated . (2017)","title":"Plotting interfaces"}]}